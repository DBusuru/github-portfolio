var rrwebRecord = (function () {
    'use strict';

    var NodeType;
    (function(NodeType2) {
      NodeType2[NodeType2["Document"] = 0] = "Document";
      NodeType2[NodeType2["DocumentType"] = 1] = "DocumentType";
      NodeType2[NodeType2["Element"] = 2] = "Element";
      NodeType2[NodeType2["Text"] = 3] = "Text";
      NodeType2[NodeType2["CDATA"] = 4] = "CDATA";
      NodeType2[NodeType2["Comment"] = 5] = "Comment";
    })(NodeType || (NodeType = {}));
    function isElement(n) {
      return n.nodeType === n.ELEMENT_NODE;
    }
    function isShadowRoot(n) {
      const host = n === null || n === void 0 ? void 0 : n.host;
      return Boolean((host === null || host === void 0 ? void 0 : host.shadowRoot) === n);
    }
    function isNativeShadowDom(shadowRoot) {
      return Object.prototype.toString.call(shadowRoot) === "[object ShadowRoot]";
    }
    function fixBrowserCompatibilityIssuesInCSS(cssText) {
      if (cssText.includes(" background-clip: text;") && !cssText.includes(" -webkit-background-clip: text;")) {
        cssText = cssText.replace(" background-clip: text;", " -webkit-background-clip: text; background-clip: text;");
      }
      return cssText;
    }
    function escapeImportStatement(rule) {
      const { cssText } = rule;
      if (cssText.split('"').length < 3)
        return cssText;
      const statement = ["@import", `url(${JSON.stringify(rule.href)})`];
      if (rule.layerName === "") {
        statement.push(`layer`);
      } else if (rule.layerName) {
        statement.push(`layer(${rule.layerName})`);
      }
      if (rule.supportsText) {
        statement.push(`supports(${rule.supportsText})`);
      }
      if (rule.media.length) {
        statement.push(rule.media.mediaText);
      }
      return statement.join(" ") + ";";
    }
    function stringifyStylesheet(s) {
      try {
        const rules = s.rules || s.cssRules;
        return rules ? fixBrowserCompatibilityIssuesInCSS(Array.from(rules, stringifyRule).join("")) : null;
      } catch (error) {
        return null;
      }
    }
    function stringifyRule(rule) {
      let importStringified;
      if (isCSSImportRule(rule)) {
        try {
          importStringified = stringifyStylesheet(rule.styleSheet) || escapeImportStatement(rule);
        } catch (error) {
        }
      } else if (isCSSStyleRule(rule) && rule.selectorText.includes(":")) {
        return fixSafariColons(rule.cssText);
      }
      return importStringified || rule.cssText;
    }
    function fixSafariColons(cssStringified) {
      const regex = /(\[(?:[\w-]+)[^\\])(:(?:[\w-]+)\])/gm;
      return cssStringified.replace(regex, "$1\\$2");
    }
    function isCSSImportRule(rule) {
      return "styleSheet" in rule;
    }
    function isCSSStyleRule(rule) {
      return "selectorText" in rule;
    }
    class Mirror {
      constructor() {
        this.idNodeMap = /* @__PURE__ */ new Map();
        this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
      }
      getId(n) {
        var _a;
        if (!n)
          return -1;
        const id = (_a = this.getMeta(n)) === null || _a === void 0 ? void 0 : _a.id;
        return id !== null && id !== void 0 ? id : -1;
      }
      getNode(id) {
        return this.idNodeMap.get(id) || null;
      }
      getIds() {
        return Array.from(this.idNodeMap.keys());
      }
      getMeta(n) {
        return this.nodeMetaMap.get(n) || null;
      }
      removeNodeFromMap(n) {
        const id = this.getId(n);
        this.idNodeMap.delete(id);
        if (n.childNodes) {
          n.childNodes.forEach((childNode) => this.removeNodeFromMap(childNode));
        }
      }
      has(id) {
        return this.idNodeMap.has(id);
      }
      hasNode(node) {
        return this.nodeMetaMap.has(node);
      }
      add(n, meta) {
        const id = meta.id;
        this.idNodeMap.set(id, n);
        this.nodeMetaMap.set(n, meta);
      }
      replace(id, n) {
        const oldNode = this.getNode(id);
        if (oldNode) {
          const meta = this.nodeMetaMap.get(oldNode);
          if (meta)
            this.nodeMetaMap.set(n, meta);
        }
        this.idNodeMap.set(id, n);
      }
      reset() {
        this.idNodeMap = /* @__PURE__ */ new Map();
        this.nodeMetaMap = /* @__PURE__ */ new WeakMap();
      }
    }
    function createMirror() {
      return new Mirror();
    }
    function maskInputValue({ element, maskInputOptions, tagName, type, value, maskInputFn }) {
      let text = value || "";
      const actualType = type && toLowerCase(type);
      if (maskInputOptions[tagName.toLowerCase()] || actualType && maskInputOptions[actualType]) {
        if (maskInputFn) {
          text = maskInputFn(text, element);
        } else {
          text = "*".repeat(text.length);
        }
      }
      return text;
    }
    function toLowerCase(str) {
      return str.toLowerCase();
    }
    const ORIGINAL_ATTRIBUTE_NAME = "__rrweb_original__";
    function is2DCanvasBlank(canvas) {
      const ctx = canvas.getContext("2d");
      if (!ctx)
        return true;
      const chunkSize = 50;
      for (let x = 0; x < canvas.width; x += chunkSize) {
        for (let y = 0; y < canvas.height; y += chunkSize) {
          const getImageData = ctx.getImageData;
          const originalGetImageData = ORIGINAL_ATTRIBUTE_NAME in getImageData ? getImageData[ORIGINAL_ATTRIBUTE_NAME] : getImageData;
          const pixelBuffer = new Uint32Array(originalGetImageData.call(ctx, x, y, Math.min(chunkSize, canvas.width - x), Math.min(chunkSize, canvas.height - y)).data.buffer);
          if (pixelBuffer.some((pixel) => pixel !== 0))
            return false;
        }
      }
      return true;
    }
    function getInputType(element) {
      const type = element.type;
      return element.hasAttribute("data-rr-is-password") ? "password" : type ? toLowerCase(type) : null;
    }
    function extractFileExtension(path, baseURL) {
      var _a;
      let url;
      try {
        url = new URL(path, baseURL !== null && baseURL !== void 0 ? baseURL : window.location.href);
      } catch (err) {
        return null;
      }
      const regex = /\.([0-9a-z]+)(?:$)/i;
      const match = url.pathname.match(regex);
      return (_a = match === null || match === void 0 ? void 0 : match[1]) !== null && _a !== void 0 ? _a : null;
    }
    let _id = 1;
    const tagNameRegex = new RegExp("[^a-z0-9-_:]");
    const IGNORED_NODE = -2;
    function genId() {
      return _id++;
    }
    function getValidTagName(element) {
      if (element instanceof HTMLFormElement) {
        return "form";
      }
      const processedTagName = toLowerCase(element.tagName);
      if (tagNameRegex.test(processedTagName)) {
        return "div";
      }
      return processedTagName;
    }
    function extractOrigin(url) {
      let origin = "";
      if (url.indexOf("//") > -1) {
        origin = url.split("/").slice(0, 3).join("/");
      } else {
        origin = url.split("/")[0];
      }
      origin = origin.split("?")[0];
      return origin;
    }
    let canvasService;
    let canvasCtx;
    const URL_IN_CSS_REF = /url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm;
    const URL_PROTOCOL_MATCH = /^(?:[a-z+]+:)?\/\//i;
    const URL_WWW_MATCH = /^www\..*/i;
    const DATA_URI = /^(data:)([^,]*),(.*)/i;
    function absoluteToStylesheet(cssText, href) {
      return (cssText || "").replace(URL_IN_CSS_REF, (origin, quote1, path1, quote2, path2, path3) => {
        const filePath = path1 || path2 || path3;
        const maybeQuote = quote1 || quote2 || "";
        if (!filePath) {
          return origin;
        }
        if (URL_PROTOCOL_MATCH.test(filePath) || URL_WWW_MATCH.test(filePath)) {
          return `url(${maybeQuote}${filePath}${maybeQuote})`;
        }
        if (DATA_URI.test(filePath)) {
          return `url(${maybeQuote}${filePath}${maybeQuote})`;
        }
        if (filePath[0] === "/") {
          return `url(${maybeQuote}${extractOrigin(href) + filePath}${maybeQuote})`;
        }
        const stack = href.split("/");
        const parts = filePath.split("/");
        stack.pop();
        for (const part of parts) {
          if (part === ".") {
            continue;
          } else if (part === "..") {
            stack.pop();
          } else {
            stack.push(part);
          }
        }
        return `url(${maybeQuote}${stack.join("/")}${maybeQuote})`;
      });
    }
    const SRCSET_NOT_SPACES = /^[^ \t\n\r\u000c]+/;
    const SRCSET_COMMAS_OR_SPACES = /^[, \t\n\r\u000c]+/;
    function getAbsoluteSrcsetString(doc, attributeValue) {
      if (attributeValue.trim() === "") {
        return attributeValue;
      }
      let pos = 0;
      function collectCharacters(regEx) {
        let chars;
        const match = regEx.exec(attributeValue.substring(pos));
        if (match) {
          chars = match[0];
          pos += chars.length;
          return chars;
        }
        return "";
      }
      const output = [];
      while (true) {
        collectCharacters(SRCSET_COMMAS_OR_SPACES);
        if (pos >= attributeValue.length) {
          break;
        }
        let url = collectCharacters(SRCSET_NOT_SPACES);
        if (url.slice(-1) === ",") {
          url = absoluteToDoc(doc, url.substring(0, url.length - 1));
          output.push(url);
        } else {
          let descriptorsStr = "";
          url = absoluteToDoc(doc, url);
          let inParens = false;
          while (true) {
            const c = attributeValue.charAt(pos);
            if (c === "") {
              output.push((url + descriptorsStr).trim());
              break;
            } else if (!inParens) {
              if (c === ",") {
                pos += 1;
                output.push((url + descriptorsStr).trim());
                break;
              } else if (c === "(") {
                inParens = true;
              }
            } else {
              if (c === ")") {
                inParens = false;
              }
            }
            descriptorsStr += c;
            pos += 1;
          }
        }
      }
      return output.join(", ");
    }
    function absoluteToDoc(doc, attributeValue) {
      if (!attributeValue || attributeValue.trim() === "") {
        return attributeValue;
      }
      const a = doc.createElement("a");
      a.href = attributeValue;
      return a.href;
    }
    function isSVGElement(el) {
      return Boolean(el.tagName === "svg" || el.ownerSVGElement);
    }
    function getHref() {
      const a = document.createElement("a");
      a.href = "";
      return a.href;
    }
    function transformAttribute(doc, tagName, name, value) {
      if (!value) {
        return value;
      }
      if (name === "src" || name === "href" && !(tagName === "use" && value[0] === "#")) {
        return absoluteToDoc(doc, value);
      } else if (name === "xlink:href" && value[0] !== "#") {
        return absoluteToDoc(doc, value);
      } else if (name === "background" && (tagName === "table" || tagName === "td" || tagName === "th")) {
        return absoluteToDoc(doc, value);
      } else if (name === "srcset") {
        return getAbsoluteSrcsetString(doc, value);
      } else if (name === "style") {
        return absoluteToStylesheet(value, getHref());
      } else if (tagName === "object" && name === "data") {
        return absoluteToDoc(doc, value);
      }
      return value;
    }
    function ignoreAttribute(tagName, name, _value) {
      return (tagName === "video" || tagName === "audio") && name === "autoplay";
    }
    function _isBlockedElement(element, blockClass, blockSelector) {
      try {
        if (typeof blockClass === "string") {
          if (element.classList.contains(blockClass)) {
            return true;
          }
        } else {
          for (let eIndex = element.classList.length; eIndex--; ) {
            const className = element.classList[eIndex];
            if (blockClass.test(className)) {
              return true;
            }
          }
        }
        if (blockSelector) {
          return element.matches(blockSelector);
        }
      } catch (e) {
      }
      return false;
    }
    function classMatchesRegex(node, regex, checkAncestors) {
      if (!node)
        return false;
      if (node.nodeType !== node.ELEMENT_NODE) {
        if (!checkAncestors)
          return false;
        return classMatchesRegex(node.parentNode, regex, checkAncestors);
      }
      for (let eIndex = node.classList.length; eIndex--; ) {
        const className = node.classList[eIndex];
        if (regex.test(className)) {
          return true;
        }
      }
      if (!checkAncestors)
        return false;
      return classMatchesRegex(node.parentNode, regex, checkAncestors);
    }
    function needMaskingText(node, maskTextClass, maskTextSelector, checkAncestors) {
      try {
        const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;
        if (el === null)
          return false;
        if (typeof maskTextClass === "string") {
          if (checkAncestors) {
            if (el.closest(`.${maskTextClass}`))
              return true;
          } else {
            if (el.classList.contains(maskTextClass))
              return true;
          }
        } else {
          if (classMatchesRegex(el, maskTextClass, checkAncestors))
            return true;
        }
        if (maskTextSelector) {
          if (checkAncestors) {
            if (el.closest(maskTextSelector))
              return true;
          } else {
            if (el.matches(maskTextSelector))
              return true;
          }
        }
      } catch (e) {
      }
      return false;
    }
    function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
      const win = iframeEl.contentWindow;
      if (!win) {
        return;
      }
      let fired = false;
      let readyState;
      try {
        readyState = win.document.readyState;
      } catch (error) {
        return;
      }
      if (readyState !== "complete") {
        const timer = setTimeout(() => {
          if (!fired) {
            listener();
            fired = true;
          }
        }, iframeLoadTimeout);
        iframeEl.addEventListener("load", () => {
          clearTimeout(timer);
          fired = true;
          listener();
        });
        return;
      }
      const blankUrl = "about:blank";
      if (win.location.href !== blankUrl || iframeEl.src === blankUrl || iframeEl.src === "") {
        setTimeout(listener, 0);
        return iframeEl.addEventListener("load", listener);
      }
      iframeEl.addEventListener("load", listener);
    }
    function onceStylesheetLoaded(link, listener, styleSheetLoadTimeout) {
      let fired = false;
      let styleSheetLoaded;
      try {
        styleSheetLoaded = link.sheet;
      } catch (error) {
        return;
      }
      if (styleSheetLoaded)
        return;
      const timer = setTimeout(() => {
        if (!fired) {
          listener();
          fired = true;
        }
      }, styleSheetLoadTimeout);
      link.addEventListener("load", () => {
        clearTimeout(timer);
        fired = true;
        listener();
      });
    }
    function serializeNode(n, options) {
      const { doc, mirror, blockClass, blockSelector, needsMask, inlineStylesheet, maskInputOptions = {}, maskTextFn, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false } = options;
      const rootId = getRootId(doc, mirror);
      switch (n.nodeType) {
        case n.DOCUMENT_NODE:
          if (n.compatMode !== "CSS1Compat") {
            return {
              type: NodeType.Document,
              childNodes: [],
              compatMode: n.compatMode
            };
          } else {
            return {
              type: NodeType.Document,
              childNodes: []
            };
          }
        case n.DOCUMENT_TYPE_NODE:
          return {
            type: NodeType.DocumentType,
            name: n.name,
            publicId: n.publicId,
            systemId: n.systemId,
            rootId
          };
        case n.ELEMENT_NODE:
          return serializeElementNode(n, {
            doc,
            blockClass,
            blockSelector,
            inlineStylesheet,
            maskInputOptions,
            maskInputFn,
            dataURLOptions,
            inlineImages,
            recordCanvas,
            keepIframeSrcFn,
            newlyAddedElement,
            rootId
          });
        case n.TEXT_NODE:
          return serializeTextNode(n, {
            needsMask,
            maskTextFn,
            rootId
          });
        case n.CDATA_SECTION_NODE:
          return {
            type: NodeType.CDATA,
            textContent: "",
            rootId
          };
        case n.COMMENT_NODE:
          return {
            type: NodeType.Comment,
            textContent: n.textContent || "",
            rootId
          };
        default:
          return false;
      }
    }
    function getRootId(doc, mirror) {
      if (!mirror.hasNode(doc))
        return void 0;
      const docId = mirror.getId(doc);
      return docId === 1 ? void 0 : docId;
    }
    function serializeTextNode(n, options) {
      var _a;
      const { needsMask, maskTextFn, rootId } = options;
      const parentTagName = n.parentNode && n.parentNode.tagName;
      let textContent = n.textContent;
      const isStyle = parentTagName === "STYLE" ? true : void 0;
      const isScript = parentTagName === "SCRIPT" ? true : void 0;
      if (isStyle && textContent) {
        try {
          if (n.nextSibling || n.previousSibling) {
          } else if ((_a = n.parentNode.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) {
            textContent = stringifyStylesheet(n.parentNode.sheet);
          }
        } catch (err) {
          console.warn(`Cannot get CSS styles from text's parentNode. Error: ${err}`, n);
        }
        textContent = absoluteToStylesheet(textContent, getHref());
      }
      if (isScript) {
        textContent = "SCRIPT_PLACEHOLDER";
      }
      if (!isStyle && !isScript && textContent && needsMask) {
        textContent = maskTextFn ? maskTextFn(textContent, n.parentElement) : textContent.replace(/[\S]/g, "*");
      }
      return {
        type: NodeType.Text,
        textContent: textContent || "",
        isStyle,
        rootId
      };
    }
    function serializeElementNode(n, options) {
      const { doc, blockClass, blockSelector, inlineStylesheet, maskInputOptions = {}, maskInputFn, dataURLOptions = {}, inlineImages, recordCanvas, keepIframeSrcFn, newlyAddedElement = false, rootId } = options;
      const needBlock = _isBlockedElement(n, blockClass, blockSelector);
      const tagName = getValidTagName(n);
      let attributes = {};
      const len = n.attributes.length;
      for (let i = 0; i < len; i++) {
        const attr = n.attributes[i];
        if (!ignoreAttribute(tagName, attr.name, attr.value)) {
          attributes[attr.name] = transformAttribute(doc, tagName, toLowerCase(attr.name), attr.value);
        }
      }
      if (tagName === "link" && inlineStylesheet) {
        const stylesheet = Array.from(doc.styleSheets).find((s) => {
          return s.href === n.href;
        });
        let cssText = null;
        if (stylesheet) {
          cssText = stringifyStylesheet(stylesheet);
        }
        if (cssText) {
          delete attributes.rel;
          delete attributes.href;
          attributes._cssText = absoluteToStylesheet(cssText, stylesheet.href);
        }
      }
      if (tagName === "style" && n.sheet && !(n.innerText || n.textContent || "").trim().length) {
        const cssText = stringifyStylesheet(n.sheet);
        if (cssText) {
          attributes._cssText = absoluteToStylesheet(cssText, getHref());
        }
      }
      if (tagName === "input" || tagName === "textarea" || tagName === "select") {
        const value = n.value;
        const checked = n.checked;
        if (attributes.type !== "radio" && attributes.type !== "checkbox" && attributes.type !== "submit" && attributes.type !== "button" && value) {
          attributes.value = maskInputValue({
            element: n,
            type: getInputType(n),
            tagName,
            value,
            maskInputOptions,
            maskInputFn
          });
        } else if (checked) {
          attributes.checked = checked;
        }
      }
      if (tagName === "option") {
        if (n.selected && !maskInputOptions["select"]) {
          attributes.selected = true;
        } else {
          delete attributes.selected;
        }
      }
      if (tagName === "canvas" && recordCanvas) {
        if (n.__context === "2d") {
          if (!is2DCanvasBlank(n)) {
            attributes.rr_dataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);
          }
        } else if (!("__context" in n)) {
          const canvasDataURL = n.toDataURL(dataURLOptions.type, dataURLOptions.quality);
          const blankCanvas = document.createElement("canvas");
          blankCanvas.width = n.width;
          blankCanvas.height = n.height;
          const blankCanvasDataURL = blankCanvas.toDataURL(dataURLOptions.type, dataURLOptions.quality);
          if (canvasDataURL !== blankCanvasDataURL) {
            attributes.rr_dataURL = canvasDataURL;
          }
        }
      }
      if (tagName === "img" && inlineImages) {
        if (!canvasService) {
          canvasService = doc.createElement("canvas");
          canvasCtx = canvasService.getContext("2d");
        }
        const image = n;
        const oldValue = image.crossOrigin;
        image.crossOrigin = "anonymous";
        const recordInlineImage = () => {
          image.removeEventListener("load", recordInlineImage);
          try {
            canvasService.width = image.naturalWidth;
            canvasService.height = image.naturalHeight;
            canvasCtx.drawImage(image, 0, 0);
            attributes.rr_dataURL = canvasService.toDataURL(dataURLOptions.type, dataURLOptions.quality);
          } catch (err) {
            console.warn(`Cannot inline img src=${image.currentSrc}! Error: ${err}`);
          }
          oldValue ? attributes.crossOrigin = oldValue : image.removeAttribute("crossorigin");
        };
        if (image.complete && image.naturalWidth !== 0)
          recordInlineImage();
        else
          image.addEventListener("load", recordInlineImage);
      }
      if (tagName === "audio" || tagName === "video") {
        const mediaAttributes = attributes;
        mediaAttributes.rr_mediaState = n.paused ? "paused" : "played";
        mediaAttributes.rr_mediaCurrentTime = n.currentTime;
        mediaAttributes.rr_mediaPlaybackRate = n.playbackRate;
        mediaAttributes.rr_mediaMuted = n.muted;
        mediaAttributes.rr_mediaLoop = n.loop;
        mediaAttributes.rr_mediaVolume = n.volume;
      }
      if (!newlyAddedElement) {
        if (n.scrollLeft) {
          attributes.rr_scrollLeft = n.scrollLeft;
        }
        if (n.scrollTop) {
          attributes.rr_scrollTop = n.scrollTop;
        }
      }
      if (needBlock) {
        const { width, height } = n.getBoundingClientRect();
        attributes = {
          class: attributes.class,
          rr_width: `${width}px`,
          rr_height: `${height}px`
        };
      }
      if (tagName === "iframe" && !keepIframeSrcFn(attributes.src)) {
        if (!n.contentDocument) {
          attributes.rr_src = attributes.src;
        }
        delete attributes.src;
      }
      let isCustomElement;
      try {
        if (customElements.get(tagName))
          isCustomElement = true;
      } catch (e) {
      }
      return {
        type: NodeType.Element,
        tagName,
        attributes,
        childNodes: [],
        isSVG: isSVGElement(n) || void 0,
        needBlock,
        rootId,
        isCustom: isCustomElement
      };
    }
    function lowerIfExists(maybeAttr) {
      if (maybeAttr === void 0 || maybeAttr === null) {
        return "";
      } else {
        return maybeAttr.toLowerCase();
      }
    }
    function slimDOMExcluded(sn, slimDOMOptions) {
      if (slimDOMOptions.comment && sn.type === NodeType.Comment) {
        return true;
      } else if (sn.type === NodeType.Element) {
        if (slimDOMOptions.script && (sn.tagName === "script" || sn.tagName === "link" && (sn.attributes.rel === "preload" || sn.attributes.rel === "modulepreload") && sn.attributes.as === "script" || sn.tagName === "link" && sn.attributes.rel === "prefetch" && typeof sn.attributes.href === "string" && extractFileExtension(sn.attributes.href) === "js")) {
          return true;
        } else if (slimDOMOptions.headFavicon && (sn.tagName === "link" && sn.attributes.rel === "shortcut icon" || sn.tagName === "meta" && (lowerIfExists(sn.attributes.name).match(/^msapplication-tile(image|color)$/) || lowerIfExists(sn.attributes.name) === "application-name" || lowerIfExists(sn.attributes.rel) === "icon" || lowerIfExists(sn.attributes.rel) === "apple-touch-icon" || lowerIfExists(sn.attributes.rel) === "shortcut icon"))) {
          return true;
        } else if (sn.tagName === "meta") {
          if (slimDOMOptions.headMetaDescKeywords && lowerIfExists(sn.attributes.name).match(/^description|keywords$/)) {
            return true;
          } else if (slimDOMOptions.headMetaSocial && (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) || lowerIfExists(sn.attributes.name) === "pinterest")) {
            return true;
          } else if (slimDOMOptions.headMetaRobots && (lowerIfExists(sn.attributes.name) === "robots" || lowerIfExists(sn.attributes.name) === "googlebot" || lowerIfExists(sn.attributes.name) === "bingbot")) {
            return true;
          } else if (slimDOMOptions.headMetaHttpEquiv && sn.attributes["http-equiv"] !== void 0) {
            return true;
          } else if (slimDOMOptions.headMetaAuthorship && (lowerIfExists(sn.attributes.name) === "author" || lowerIfExists(sn.attributes.name) === "generator" || lowerIfExists(sn.attributes.name) === "framework" || lowerIfExists(sn.attributes.name) === "publisher" || lowerIfExists(sn.attributes.name) === "progid" || lowerIfExists(sn.attributes.property).match(/^article:/) || lowerIfExists(sn.attributes.property).match(/^product:/))) {
            return true;
          } else if (slimDOMOptions.headMetaVerification && (lowerIfExists(sn.attributes.name) === "google-site-verification" || lowerIfExists(sn.attributes.name) === "yandex-verification" || lowerIfExists(sn.attributes.name) === "csrf-token" || lowerIfExists(sn.attributes.name) === "p:domain_verify" || lowerIfExists(sn.attributes.name) === "verify-v1" || lowerIfExists(sn.attributes.name) === "verification" || lowerIfExists(sn.attributes.name) === "shopify-checkout-api-token")) {
            return true;
          }
        }
      }
      return false;
    }
    function serializeNodeWithId(n, options) {
      const { doc, mirror, blockClass, blockSelector, maskTextClass, maskTextSelector, skipChild = false, inlineStylesheet = true, maskInputOptions = {}, maskTextFn, maskInputFn, slimDOMOptions, dataURLOptions = {}, inlineImages = false, recordCanvas = false, onSerialize, onIframeLoad, iframeLoadTimeout = 5e3, onStylesheetLoad, stylesheetLoadTimeout = 5e3, keepIframeSrcFn = () => false, newlyAddedElement = false } = options;
      let { needsMask } = options;
      let { preserveWhiteSpace = true } = options;
      if (!needsMask && n.childNodes) {
        const checkAncestors = needsMask === void 0;
        needsMask = needMaskingText(n, maskTextClass, maskTextSelector, checkAncestors);
      }
      const _serializedNode = serializeNode(n, {
        doc,
        mirror,
        blockClass,
        blockSelector,
        needsMask,
        inlineStylesheet,
        maskInputOptions,
        maskTextFn,
        maskInputFn,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        keepIframeSrcFn,
        newlyAddedElement
      });
      if (!_serializedNode) {
        console.warn(n, "not serialized");
        return null;
      }
      let id;
      if (mirror.hasNode(n)) {
        id = mirror.getId(n);
      } else if (slimDOMExcluded(_serializedNode, slimDOMOptions) || !preserveWhiteSpace && _serializedNode.type === NodeType.Text && !_serializedNode.isStyle && !_serializedNode.textContent.replace(/^\s+|\s+$/gm, "").length) {
        id = IGNORED_NODE;
      } else {
        id = genId();
      }
      const serializedNode = Object.assign(_serializedNode, { id });
      mirror.add(n, serializedNode);
      if (id === IGNORED_NODE) {
        return null;
      }
      if (onSerialize) {
        onSerialize(n);
      }
      let recordChild = !skipChild;
      if (serializedNode.type === NodeType.Element) {
        recordChild = recordChild && !serializedNode.needBlock;
        delete serializedNode.needBlock;
        const shadowRoot = n.shadowRoot;
        if (shadowRoot && isNativeShadowDom(shadowRoot))
          serializedNode.isShadowHost = true;
      }
      if ((serializedNode.type === NodeType.Document || serializedNode.type === NodeType.Element) && recordChild) {
        if (slimDOMOptions.headWhitespace && serializedNode.type === NodeType.Element && serializedNode.tagName === "head") {
          preserveWhiteSpace = false;
        }
        const bypassOptions = {
          doc,
          mirror,
          blockClass,
          blockSelector,
          needsMask,
          maskTextClass,
          maskTextSelector,
          skipChild,
          inlineStylesheet,
          maskInputOptions,
          maskTextFn,
          maskInputFn,
          slimDOMOptions,
          dataURLOptions,
          inlineImages,
          recordCanvas,
          preserveWhiteSpace,
          onSerialize,
          onIframeLoad,
          iframeLoadTimeout,
          onStylesheetLoad,
          stylesheetLoadTimeout,
          keepIframeSrcFn
        };
        if (serializedNode.type === NodeType.Element && serializedNode.tagName === "textarea" && serializedNode.attributes.value !== void 0)
          ;
        else {
          for (const childN of Array.from(n.childNodes)) {
            const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
            if (serializedChildNode) {
              serializedNode.childNodes.push(serializedChildNode);
            }
          }
        }
        if (isElement(n) && n.shadowRoot) {
          for (const childN of Array.from(n.shadowRoot.childNodes)) {
            const serializedChildNode = serializeNodeWithId(childN, bypassOptions);
            if (serializedChildNode) {
              isNativeShadowDom(n.shadowRoot) && (serializedChildNode.isShadow = true);
              serializedNode.childNodes.push(serializedChildNode);
            }
          }
        }
      }
      if (n.parentNode && isShadowRoot(n.parentNode) && isNativeShadowDom(n.parentNode)) {
        serializedNode.isShadow = true;
      }
      if (serializedNode.type === NodeType.Element && serializedNode.tagName === "iframe") {
        onceIframeLoaded(n, () => {
          const iframeDoc = n.contentDocument;
          if (iframeDoc && onIframeLoad) {
            const serializedIframeNode = serializeNodeWithId(iframeDoc, {
              doc: iframeDoc,
              mirror,
              blockClass,
              blockSelector,
              needsMask,
              maskTextClass,
              maskTextSelector,
              skipChild: false,
              inlineStylesheet,
              maskInputOptions,
              maskTextFn,
              maskInputFn,
              slimDOMOptions,
              dataURLOptions,
              inlineImages,
              recordCanvas,
              preserveWhiteSpace,
              onSerialize,
              onIframeLoad,
              iframeLoadTimeout,
              onStylesheetLoad,
              stylesheetLoadTimeout,
              keepIframeSrcFn
            });
            if (serializedIframeNode) {
              onIframeLoad(n, serializedIframeNode);
            }
          }
        }, iframeLoadTimeout);
      }
      if (serializedNode.type === NodeType.Element && serializedNode.tagName === "link" && typeof serializedNode.attributes.rel === "string" && (serializedNode.attributes.rel === "stylesheet" || serializedNode.attributes.rel === "preload" && typeof serializedNode.attributes.href === "string" && extractFileExtension(serializedNode.attributes.href) === "css")) {
        onceStylesheetLoaded(n, () => {
          if (onStylesheetLoad) {
            const serializedLinkNode = serializeNodeWithId(n, {
              doc,
              mirror,
              blockClass,
              blockSelector,
              needsMask,
              maskTextClass,
              maskTextSelector,
              skipChild: false,
              inlineStylesheet,
              maskInputOptions,
              maskTextFn,
              maskInputFn,
              slimDOMOptions,
              dataURLOptions,
              inlineImages,
              recordCanvas,
              preserveWhiteSpace,
              onSerialize,
              onIframeLoad,
              iframeLoadTimeout,
              onStylesheetLoad,
              stylesheetLoadTimeout,
              keepIframeSrcFn
            });
            if (serializedLinkNode) {
              onStylesheetLoad(n, serializedLinkNode);
            }
          }
        }, stylesheetLoadTimeout);
      }
      return serializedNode;
    }
    function snapshot(n, options) {
      const { mirror = new Mirror(), blockClass = "rr-block", blockSelector = null, maskTextClass = "rr-mask", maskTextSelector = null, inlineStylesheet = true, inlineImages = false, recordCanvas = false, maskAllInputs = false, maskTextFn, maskInputFn, slimDOM = false, dataURLOptions, preserveWhiteSpace, onSerialize, onIframeLoad, iframeLoadTimeout, onStylesheetLoad, stylesheetLoadTimeout, keepIframeSrcFn = () => false } = options || {};
      const maskInputOptions = maskAllInputs === true ? {
        color: true,
        date: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true,
        textarea: true,
        select: true,
        password: true
      } : maskAllInputs === false ? {
        password: true
      } : maskAllInputs;
      const slimDOMOptions = slimDOM === true || slimDOM === "all" ? {
        script: true,
        comment: true,
        headFavicon: true,
        headWhitespace: true,
        headMetaDescKeywords: slimDOM === "all",
        headMetaSocial: true,
        headMetaRobots: true,
        headMetaHttpEquiv: true,
        headMetaAuthorship: true,
        headMetaVerification: true
      } : slimDOM === false ? {} : slimDOM;
      return serializeNodeWithId(n, {
        doc: n,
        mirror,
        blockClass,
        blockSelector,
        maskTextClass,
        maskTextSelector,
        skipChild: false,
        inlineStylesheet,
        maskInputOptions,
        maskTextFn,
        maskInputFn,
        slimDOMOptions,
        dataURLOptions,
        inlineImages,
        recordCanvas,
        preserveWhiteSpace,
        onSerialize,
        onIframeLoad,
        iframeLoadTimeout,
        onStylesheetLoad,
        stylesheetLoadTimeout,
        keepIframeSrcFn,
        newlyAddedElement: false
      });
    }

    function on(type, fn, target = document) {
      const options = { capture: true, passive: true };
      target.addEventListener(type, fn, options);
      return () => target.removeEventListener(type, fn, options);
    }
    const DEPARTED_MIRROR_ACCESS_WARNING = "Please stop import mirror directly. Instead of that,\r\nnow you can use replayer.getMirror() to access the mirror instance of a replayer,\r\nor you can use record.mirror to access the mirror instance during recording.";
    let _mirror = {
      map: {},
      getId() {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
        return -1;
      },
      getNode() {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
        return null;
      },
      removeNodeFromMap() {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      },
      has() {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
        return false;
      },
      reset() {
        console.error(DEPARTED_MIRROR_ACCESS_WARNING);
      }
    };
    if (typeof window !== "undefined" && window.Proxy && window.Reflect) {
      _mirror = new Proxy(_mirror, {
        get(target, prop, receiver) {
          if (prop === "map") {
            console.error(DEPARTED_MIRROR_ACCESS_WARNING);
          }
          return Reflect.get(target, prop, receiver);
        }
      });
    }
    function throttle(func, wait, options = {}) {
      let timeout = null;
      let previous = 0;
      return function(...args) {
        const now = Date.now();
        if (!previous && options.leading === false) {
          previous = now;
        }
        const remaining = wait - (now - previous);
        const context = this;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          func.apply(context, args);
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(() => {
            previous = options.leading === false ? 0 : Date.now();
            timeout = null;
            func.apply(context, args);
          }, remaining);
        }
      };
    }
    function hookSetter(target, key, d, isRevoked, win = window) {
      const original = win.Object.getOwnPropertyDescriptor(target, key);
      win.Object.defineProperty(target, key, isRevoked ? d : {
        set(value) {
          setTimeout(() => {
            d.set.call(this, value);
          }, 0);
          if (original && original.set) {
            original.set.call(this, value);
          }
        }
      });
      return () => hookSetter(target, key, original || {}, true);
    }
    function patch(source, name, replacement) {
      try {
        if (!(name in source)) {
          return () => {
          };
        }
        const original = source[name];
        const wrapped = replacement(original);
        if (typeof wrapped === "function") {
          wrapped.prototype = wrapped.prototype || {};
          Object.defineProperties(wrapped, {
            __rrweb_original__: {
              enumerable: false,
              value: original
            }
          });
        }
        source[name] = wrapped;
        return () => {
          source[name] = original;
        };
      } catch (e) {
        return () => {
        };
      }
    }
    let nowTimestamp = Date.now;
    if (!/* @__PURE__ */ /[1-9][0-9]{12}/.test(Date.now().toString())) {
      nowTimestamp = () => new Date().getTime();
    }
    function getWindowScroll(win) {
      var _a, _b, _c, _d, _e, _f;
      const doc = win.document;
      return {
        left: doc.scrollingElement ? doc.scrollingElement.scrollLeft : win.pageXOffset !== void 0 ? win.pageXOffset : (doc == null ? void 0 : doc.documentElement.scrollLeft) || ((_b = (_a = doc == null ? void 0 : doc.body) == null ? void 0 : _a.parentElement) == null ? void 0 : _b.scrollLeft) || ((_c = doc == null ? void 0 : doc.body) == null ? void 0 : _c.scrollLeft) || 0,
        top: doc.scrollingElement ? doc.scrollingElement.scrollTop : win.pageYOffset !== void 0 ? win.pageYOffset : (doc == null ? void 0 : doc.documentElement.scrollTop) || ((_e = (_d = doc == null ? void 0 : doc.body) == null ? void 0 : _d.parentElement) == null ? void 0 : _e.scrollTop) || ((_f = doc == null ? void 0 : doc.body) == null ? void 0 : _f.scrollTop) || 0
      };
    }
    function getWindowHeight() {
      return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight;
    }
    function getWindowWidth() {
      return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth;
    }
    function closestElementOfNode(node) {
      if (!node) {
        return null;
      }
      const el = node.nodeType === node.ELEMENT_NODE ? node : node.parentElement;
      return el;
    }
    function isBlocked(node, blockClass, blockSelector, checkAncestors) {
      if (!node) {
        return false;
      }
      const el = closestElementOfNode(node);
      if (!el) {
        return false;
      }
      try {
        if (typeof blockClass === "string") {
          if (el.classList.contains(blockClass))
            return true;
          if (checkAncestors && el.closest("." + blockClass) !== null)
            return true;
        } else {
          if (classMatchesRegex(el, blockClass, checkAncestors))
            return true;
        }
      } catch (e) {
      }
      if (blockSelector) {
        if (el.matches(blockSelector))
          return true;
        if (checkAncestors && el.closest(blockSelector) !== null)
          return true;
      }
      return false;
    }
    function isSerialized(n, mirror) {
      return mirror.getId(n) !== -1;
    }
    function isIgnored(n, mirror) {
      return mirror.getId(n) === IGNORED_NODE;
    }
    function isAncestorRemoved(target, mirror) {
      if (isShadowRoot(target)) {
        return false;
      }
      const id = mirror.getId(target);
      if (!mirror.has(id)) {
        return true;
      }
      if (target.parentNode && target.parentNode.nodeType === target.DOCUMENT_NODE) {
        return false;
      }
      if (!target.parentNode) {
        return true;
      }
      return isAncestorRemoved(target.parentNode, mirror);
    }
    function legacy_isTouchEvent(event) {
      return Boolean(event.changedTouches);
    }
    function polyfill(win = window) {
      if ("NodeList" in win && !win.NodeList.prototype.forEach) {
        win.NodeList.prototype.forEach = Array.prototype.forEach;
      }
      if ("DOMTokenList" in win && !win.DOMTokenList.prototype.forEach) {
        win.DOMTokenList.prototype.forEach = Array.prototype.forEach;
      }
      if (!Node.prototype.contains) {
        Node.prototype.contains = (...args) => {
          let node = args[0];
          if (!(0 in args)) {
            throw new TypeError("1 argument is required");
          }
          do {
            if (this === node) {
              return true;
            }
          } while (node = node && node.parentNode);
          return false;
        };
      }
    }
    function isSerializedIframe(n, mirror) {
      return Boolean(n.nodeName === "IFRAME" && mirror.getMeta(n));
    }
    function isSerializedStylesheet(n, mirror) {
      return Boolean(n.nodeName === "LINK" && n.nodeType === n.ELEMENT_NODE && n.getAttribute && n.getAttribute("rel") === "stylesheet" && mirror.getMeta(n));
    }
    function hasShadowRoot(n) {
      return Boolean(n == null ? void 0 : n.shadowRoot);
    }
    class StyleSheetMirror {
      constructor() {
        this.id = 1;
        this.styleIDMap = /* @__PURE__ */ new WeakMap();
        this.idStyleMap = /* @__PURE__ */ new Map();
      }
      getId(stylesheet) {
        var _a;
        return (_a = this.styleIDMap.get(stylesheet)) != null ? _a : -1;
      }
      has(stylesheet) {
        return this.styleIDMap.has(stylesheet);
      }
      add(stylesheet, id) {
        if (this.has(stylesheet))
          return this.getId(stylesheet);
        let newId;
        if (id === void 0) {
          newId = this.id++;
        } else
          newId = id;
        this.styleIDMap.set(stylesheet, newId);
        this.idStyleMap.set(newId, stylesheet);
        return newId;
      }
      getStyle(id) {
        return this.idStyleMap.get(id) || null;
      }
      reset() {
        this.styleIDMap = /* @__PURE__ */ new WeakMap();
        this.idStyleMap = /* @__PURE__ */ new Map();
        this.id = 1;
      }
      generateId() {
        return this.id++;
      }
    }
    function getShadowHost(n) {
      var _a, _b;
      let shadowHost = null;
      if (((_b = (_a = n.getRootNode) == null ? void 0 : _a.call(n)) == null ? void 0 : _b.nodeType) === Node.DOCUMENT_FRAGMENT_NODE && n.getRootNode().host)
        shadowHost = n.getRootNode().host;
      return shadowHost;
    }
    function getRootShadowHost(n) {
      let rootShadowHost = n;
      let shadowHost;
      while (shadowHost = getShadowHost(rootShadowHost))
        rootShadowHost = shadowHost;
      return rootShadowHost;
    }
    function shadowHostInDom(n) {
      const doc = n.ownerDocument;
      if (!doc)
        return false;
      const shadowHost = getRootShadowHost(n);
      return doc.contains(shadowHost);
    }
    function inDom(n) {
      const doc = n.ownerDocument;
      if (!doc)
        return false;
      return doc.contains(n) || shadowHostInDom(n);
    }

    var EventType = /* @__PURE__ */ ((EventType2) => {
      EventType2[EventType2["DomContentLoaded"] = 0] = "DomContentLoaded";
      EventType2[EventType2["Load"] = 1] = "Load";
      EventType2[EventType2["FullSnapshot"] = 2] = "FullSnapshot";
      EventType2[EventType2["IncrementalSnapshot"] = 3] = "IncrementalSnapshot";
      EventType2[EventType2["Meta"] = 4] = "Meta";
      EventType2[EventType2["Custom"] = 5] = "Custom";
      EventType2[EventType2["Plugin"] = 6] = "Plugin";
      return EventType2;
    })(EventType || {});
    var IncrementalSource = /* @__PURE__ */ ((IncrementalSource2) => {
      IncrementalSource2[IncrementalSource2["Mutation"] = 0] = "Mutation";
      IncrementalSource2[IncrementalSource2["MouseMove"] = 1] = "MouseMove";
      IncrementalSource2[IncrementalSource2["MouseInteraction"] = 2] = "MouseInteraction";
      IncrementalSource2[IncrementalSource2["Scroll"] = 3] = "Scroll";
      IncrementalSource2[IncrementalSource2["ViewportResize"] = 4] = "ViewportResize";
      IncrementalSource2[IncrementalSource2["Input"] = 5] = "Input";
      IncrementalSource2[IncrementalSource2["TouchMove"] = 6] = "TouchMove";
      IncrementalSource2[IncrementalSource2["MediaInteraction"] = 7] = "MediaInteraction";
      IncrementalSource2[IncrementalSource2["StyleSheetRule"] = 8] = "StyleSheetRule";
      IncrementalSource2[IncrementalSource2["CanvasMutation"] = 9] = "CanvasMutation";
      IncrementalSource2[IncrementalSource2["Font"] = 10] = "Font";
      IncrementalSource2[IncrementalSource2["Log"] = 11] = "Log";
      IncrementalSource2[IncrementalSource2["Drag"] = 12] = "Drag";
      IncrementalSource2[IncrementalSource2["StyleDeclaration"] = 13] = "StyleDeclaration";
      IncrementalSource2[IncrementalSource2["Selection"] = 14] = "Selection";
      IncrementalSource2[IncrementalSource2["AdoptedStyleSheet"] = 15] = "AdoptedStyleSheet";
      IncrementalSource2[IncrementalSource2["CustomElement"] = 16] = "CustomElement";
      return IncrementalSource2;
    })(IncrementalSource || {});
    var MouseInteractions = /* @__PURE__ */ ((MouseInteractions2) => {
      MouseInteractions2[MouseInteractions2["MouseUp"] = 0] = "MouseUp";
      MouseInteractions2[MouseInteractions2["MouseDown"] = 1] = "MouseDown";
      MouseInteractions2[MouseInteractions2["Click"] = 2] = "Click";
      MouseInteractions2[MouseInteractions2["ContextMenu"] = 3] = "ContextMenu";
      MouseInteractions2[MouseInteractions2["DblClick"] = 4] = "DblClick";
      MouseInteractions2[MouseInteractions2["Focus"] = 5] = "Focus";
      MouseInteractions2[MouseInteractions2["Blur"] = 6] = "Blur";
      MouseInteractions2[MouseInteractions2["TouchStart"] = 7] = "TouchStart";
      MouseInteractions2[MouseInteractions2["TouchMove_Departed"] = 8] = "TouchMove_Departed";
      MouseInteractions2[MouseInteractions2["TouchEnd"] = 9] = "TouchEnd";
      MouseInteractions2[MouseInteractions2["TouchCancel"] = 10] = "TouchCancel";
      return MouseInteractions2;
    })(MouseInteractions || {});
    var PointerTypes = /* @__PURE__ */ ((PointerTypes2) => {
      PointerTypes2[PointerTypes2["Mouse"] = 0] = "Mouse";
      PointerTypes2[PointerTypes2["Pen"] = 1] = "Pen";
      PointerTypes2[PointerTypes2["Touch"] = 2] = "Touch";
      return PointerTypes2;
    })(PointerTypes || {});
    var CanvasContext = /* @__PURE__ */ ((CanvasContext2) => {
      CanvasContext2[CanvasContext2["2D"] = 0] = "2D";
      CanvasContext2[CanvasContext2["WebGL"] = 1] = "WebGL";
      CanvasContext2[CanvasContext2["WebGL2"] = 2] = "WebGL2";
      return CanvasContext2;
    })(CanvasContext || {});
    var MediaInteractions = /* @__PURE__ */ ((MediaInteractions2) => {
      MediaInteractions2[MediaInteractions2["Play"] = 0] = "Play";
      MediaInteractions2[MediaInteractions2["Pause"] = 1] = "Pause";
      MediaInteractions2[MediaInteractions2["Seeked"] = 2] = "Seeked";
      MediaInteractions2[MediaInteractions2["VolumeChange"] = 3] = "VolumeChange";
      MediaInteractions2[MediaInteractions2["RateChange"] = 4] = "RateChange";
      return MediaInteractions2;
    })(MediaInteractions || {});

    function isNodeInLinkedList(n) {
      return "__ln" in n;
    }
    class DoubleLinkedList {
      constructor() {
        this.length = 0;
        this.head = null;
        this.tail = null;
      }
      get(position) {
        if (position >= this.length) {
          throw new Error("Position outside of list range");
        }
        let current = this.head;
        for (let index = 0; index < position; index++) {
          current = (current == null ? void 0 : current.next) || null;
        }
        return current;
      }
      addNode(n) {
        const node = {
          value: n,
          previous: null,
          next: null
        };
        n.__ln = node;
        if (n.previousSibling && isNodeInLinkedList(n.previousSibling)) {
          const current = n.previousSibling.__ln.next;
          node.next = current;
          node.previous = n.previousSibling.__ln;
          n.previousSibling.__ln.next = node;
          if (current) {
            current.previous = node;
          }
        } else if (n.nextSibling && isNodeInLinkedList(n.nextSibling) && n.nextSibling.__ln.previous) {
          const current = n.nextSibling.__ln.previous;
          node.previous = current;
          node.next = n.nextSibling.__ln;
          n.nextSibling.__ln.previous = node;
          if (current) {
            current.next = node;
          }
        } else {
          if (this.head) {
            this.head.previous = node;
          }
          node.next = this.head;
          this.head = node;
        }
        if (node.next === null) {
          this.tail = node;
        }
        this.length++;
      }
      removeNode(n) {
        const current = n.__ln;
        if (!this.head) {
          return;
        }
        if (!current.previous) {
          this.head = current.next;
          if (this.head) {
            this.head.previous = null;
          } else {
            this.tail = null;
          }
        } else {
          current.previous.next = current.next;
          if (current.next) {
            current.next.previous = current.previous;
          } else {
            this.tail = current.previous;
          }
        }
        if (n.__ln) {
          delete n.__ln;
        }
        this.length--;
      }
    }
    const moveKey = (id, parentId) => `${id}@${parentId}`;
    class MutationBuffer {
      constructor() {
        this.frozen = false;
        this.locked = false;
        this.texts = [];
        this.attributes = [];
        this.attributeMap = /* @__PURE__ */ new WeakMap();
        this.removes = [];
        this.mapRemoves = [];
        this.movedMap = {};
        this.addedSet = /* @__PURE__ */ new Set();
        this.movedSet = /* @__PURE__ */ new Set();
        this.droppedSet = /* @__PURE__ */ new Set();
        this.processMutations = (mutations) => {
          mutations.forEach(this.processMutation);
          this.emit();
        };
        this.emit = () => {
          if (this.frozen || this.locked) {
            return;
          }
          const adds = [];
          const addedIds = /* @__PURE__ */ new Set();
          const addList = new DoubleLinkedList();
          const getNextId = (n) => {
            let ns = n;
            let nextId = IGNORED_NODE;
            while (nextId === IGNORED_NODE) {
              ns = ns && ns.nextSibling;
              nextId = ns && this.mirror.getId(ns);
            }
            return nextId;
          };
          const pushAdd = (n) => {
            if (!n.parentNode || !inDom(n) || n.parentNode.tagName === "TEXTAREA") {
              return;
            }
            const parentId = isShadowRoot(n.parentNode) ? this.mirror.getId(getShadowHost(n)) : this.mirror.getId(n.parentNode);
            const nextId = getNextId(n);
            if (parentId === -1 || nextId === -1) {
              return addList.addNode(n);
            }
            const sn = serializeNodeWithId(n, {
              doc: this.doc,
              mirror: this.mirror,
              blockClass: this.blockClass,
              blockSelector: this.blockSelector,
              maskTextClass: this.maskTextClass,
              maskTextSelector: this.maskTextSelector,
              skipChild: true,
              newlyAddedElement: true,
              inlineStylesheet: this.inlineStylesheet,
              maskInputOptions: this.maskInputOptions,
              maskTextFn: this.maskTextFn,
              maskInputFn: this.maskInputFn,
              slimDOMOptions: this.slimDOMOptions,
              dataURLOptions: this.dataURLOptions,
              recordCanvas: this.recordCanvas,
              inlineImages: this.inlineImages,
              onSerialize: (currentN) => {
                if (isSerializedIframe(currentN, this.mirror)) {
                  this.iframeManager.addIframe(currentN);
                }
                if (isSerializedStylesheet(currentN, this.mirror)) {
                  this.stylesheetManager.trackLinkElement(currentN);
                }
                if (hasShadowRoot(n)) {
                  this.shadowDomManager.addShadowRoot(n.shadowRoot, this.doc);
                }
              },
              onIframeLoad: (iframe, childSn) => {
                this.iframeManager.attachIframe(iframe, childSn);
                this.shadowDomManager.observeAttachShadow(iframe);
              },
              onStylesheetLoad: (link, childSn) => {
                this.stylesheetManager.attachLinkElement(link, childSn);
              }
            });
            if (sn) {
              adds.push({
                parentId,
                nextId,
                node: sn
              });
              addedIds.add(sn.id);
            }
          };
          while (this.mapRemoves.length) {
            this.mirror.removeNodeFromMap(this.mapRemoves.shift());
          }
          for (const n of this.movedSet) {
            if (isParentRemoved(this.removes, n, this.mirror) && !this.movedSet.has(n.parentNode)) {
              continue;
            }
            pushAdd(n);
          }
          for (const n of this.addedSet) {
            if (!isAncestorInSet(this.droppedSet, n) && !isParentRemoved(this.removes, n, this.mirror)) {
              pushAdd(n);
            } else if (isAncestorInSet(this.movedSet, n)) {
              pushAdd(n);
            } else {
              this.droppedSet.add(n);
            }
          }
          let candidate = null;
          while (addList.length) {
            let node = null;
            if (candidate) {
              const parentId = this.mirror.getId(candidate.value.parentNode);
              const nextId = getNextId(candidate.value);
              if (parentId !== -1 && nextId !== -1) {
                node = candidate;
              }
            }
            if (!node) {
              let tailNode = addList.tail;
              while (tailNode) {
                const _node = tailNode;
                tailNode = tailNode.previous;
                if (_node) {
                  const parentId = this.mirror.getId(_node.value.parentNode);
                  const nextId = getNextId(_node.value);
                  if (nextId === -1)
                    continue;
                  else if (parentId !== -1) {
                    node = _node;
                    break;
                  } else {
                    const unhandledNode = _node.value;
                    if (unhandledNode.parentNode && unhandledNode.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
                      const shadowHost = unhandledNode.parentNode.host;
                      const parentId2 = this.mirror.getId(shadowHost);
                      if (parentId2 !== -1) {
                        node = _node;
                        break;
                      }
                    }
                  }
                }
              }
            }
            if (!node) {
              while (addList.head) {
                addList.removeNode(addList.head.value);
              }
              break;
            }
            candidate = node.previous;
            addList.removeNode(node.value);
            pushAdd(node.value);
          }
          const payload = {
            texts: this.texts.map((text) => {
              const n = text.node;
              if (n.parentNode && n.parentNode.tagName === "TEXTAREA") {
                this.genTextAreaValueMutation(n.parentNode);
              }
              return {
                id: this.mirror.getId(n),
                value: text.value
              };
            }).filter((text) => !addedIds.has(text.id)).filter((text) => this.mirror.has(text.id)),
            attributes: this.attributes.map((attribute) => {
              const { attributes } = attribute;
              if (typeof attributes.style === "string") {
                const diffAsStr = JSON.stringify(attribute.styleDiff);
                const unchangedAsStr = JSON.stringify(attribute._unchangedStyles);
                if (diffAsStr.length < attributes.style.length) {
                  if ((diffAsStr + unchangedAsStr).split("var(").length === attributes.style.split("var(").length) {
                    attributes.style = attribute.styleDiff;
                  }
                }
              }
              return {
                id: this.mirror.getId(attribute.node),
                attributes
              };
            }).filter((attribute) => !addedIds.has(attribute.id)).filter((attribute) => this.mirror.has(attribute.id)),
            removes: this.removes,
            adds
          };
          if (!payload.texts.length && !payload.attributes.length && !payload.removes.length && !payload.adds.length) {
            return;
          }
          this.texts = [];
          this.attributes = [];
          this.attributeMap = /* @__PURE__ */ new WeakMap();
          this.removes = [];
          this.addedSet = /* @__PURE__ */ new Set();
          this.movedSet = /* @__PURE__ */ new Set();
          this.droppedSet = /* @__PURE__ */ new Set();
          this.movedMap = {};
          this.mutationCb(payload);
        };
        this.genTextAreaValueMutation = (textarea) => {
          let item = this.attributeMap.get(textarea);
          if (!item) {
            item = {
              node: textarea,
              attributes: {},
              styleDiff: {},
              _unchangedStyles: {}
            };
            this.attributes.push(item);
            this.attributeMap.set(textarea, item);
          }
          item.attributes.value = Array.from(textarea.childNodes, (cn) => cn.textContent || "").join("");
        };
        this.processMutation = (m) => {
          if (isIgnored(m.target, this.mirror)) {
            return;
          }
          switch (m.type) {
            case "characterData": {
              const value = m.target.textContent;
              if (!isBlocked(m.target, this.blockClass, this.blockSelector, false) && value !== m.oldValue) {
                this.texts.push({
                  value: needMaskingText(m.target, this.maskTextClass, this.maskTextSelector, true) && value ? this.maskTextFn ? this.maskTextFn(value, closestElementOfNode(m.target)) : value.replace(/[\S]/g, "*") : value,
                  node: m.target
                });
              }
              break;
            }
            case "attributes": {
              const target = m.target;
              let attributeName = m.attributeName;
              let value = m.target.getAttribute(attributeName);
              if (attributeName === "value") {
                const type = getInputType(target);
                value = maskInputValue({
                  element: target,
                  maskInputOptions: this.maskInputOptions,
                  tagName: target.tagName,
                  type,
                  value,
                  maskInputFn: this.maskInputFn
                });
              }
              if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || value === m.oldValue) {
                return;
              }
              let item = this.attributeMap.get(m.target);
              if (target.tagName === "IFRAME" && attributeName === "src" && !this.keepIframeSrcFn(value)) {
                if (!target.contentDocument) {
                  attributeName = "rr_src";
                } else {
                  return;
                }
              }
              if (!item) {
                item = {
                  node: m.target,
                  attributes: {},
                  styleDiff: {},
                  _unchangedStyles: {}
                };
                this.attributes.push(item);
                this.attributeMap.set(m.target, item);
              }
              if (attributeName === "type" && target.tagName === "INPUT" && (m.oldValue || "").toLowerCase() === "password") {
                target.setAttribute("data-rr-is-password", "true");
              }
              if (!ignoreAttribute(target.tagName, attributeName)) {
                item.attributes[attributeName] = transformAttribute(this.doc, toLowerCase(target.tagName), toLowerCase(attributeName), value);
                if (attributeName === "style") {
                  if (!this.unattachedDoc) {
                    try {
                      this.unattachedDoc = document.implementation.createHTMLDocument();
                    } catch (e) {
                      this.unattachedDoc = this.doc;
                    }
                  }
                  const old = this.unattachedDoc.createElement("span");
                  if (m.oldValue) {
                    old.setAttribute("style", m.oldValue);
                  }
                  for (const pname of Array.from(target.style)) {
                    const newValue = target.style.getPropertyValue(pname);
                    const newPriority = target.style.getPropertyPriority(pname);
                    if (newValue !== old.style.getPropertyValue(pname) || newPriority !== old.style.getPropertyPriority(pname)) {
                      if (newPriority === "") {
                        item.styleDiff[pname] = newValue;
                      } else {
                        item.styleDiff[pname] = [newValue, newPriority];
                      }
                    } else {
                      item._unchangedStyles[pname] = [newValue, newPriority];
                    }
                  }
                  for (const pname of Array.from(old.style)) {
                    if (target.style.getPropertyValue(pname) === "") {
                      item.styleDiff[pname] = false;
                    }
                  }
                }
              }
              break;
            }
            case "childList": {
              if (isBlocked(m.target, this.blockClass, this.blockSelector, true))
                return;
              if (m.target.tagName === "TEXTAREA") {
                this.genTextAreaValueMutation(m.target);
                return;
              }
              m.addedNodes.forEach((n) => this.genAdds(n, m.target));
              m.removedNodes.forEach((n) => {
                const nodeId = this.mirror.getId(n);
                const parentId = isShadowRoot(m.target) ? this.mirror.getId(m.target.host) : this.mirror.getId(m.target);
                if (isBlocked(m.target, this.blockClass, this.blockSelector, false) || isIgnored(n, this.mirror) || !isSerialized(n, this.mirror)) {
                  return;
                }
                if (this.addedSet.has(n)) {
                  deepDelete(this.addedSet, n);
                  this.droppedSet.add(n);
                } else if (this.addedSet.has(m.target) && nodeId === -1) ; else if (isAncestorRemoved(m.target, this.mirror)) ; else if (this.movedSet.has(n) && this.movedMap[moveKey(nodeId, parentId)]) {
                  deepDelete(this.movedSet, n);
                } else {
                  this.removes.push({
                    parentId,
                    id: nodeId,
                    isShadow: isShadowRoot(m.target) && isNativeShadowDom(m.target) ? true : void 0
                  });
                }
                this.mapRemoves.push(n);
              });
              break;
            }
          }
        };
        this.genAdds = (n, target) => {
          if (this.processedNodeManager.inOtherBuffer(n, this))
            return;
          if (this.addedSet.has(n) || this.movedSet.has(n))
            return;
          if (this.mirror.hasNode(n)) {
            if (isIgnored(n, this.mirror)) {
              return;
            }
            this.movedSet.add(n);
            let targetId = null;
            if (target && this.mirror.hasNode(target)) {
              targetId = this.mirror.getId(target);
            }
            if (targetId && targetId !== -1) {
              this.movedMap[moveKey(this.mirror.getId(n), targetId)] = true;
            }
          } else {
            this.addedSet.add(n);
            this.droppedSet.delete(n);
          }
          if (!isBlocked(n, this.blockClass, this.blockSelector, false)) {
            n.childNodes.forEach((childN) => this.genAdds(childN));
            if (hasShadowRoot(n)) {
              n.shadowRoot.childNodes.forEach((childN) => {
                this.processedNodeManager.add(childN, this);
                this.genAdds(childN, n);
              });
            }
          }
        };
      }
      init(options) {
        [
          "mutationCb",
          "blockClass",
          "blockSelector",
          "maskTextClass",
          "maskTextSelector",
          "inlineStylesheet",
          "maskInputOptions",
          "maskTextFn",
          "maskInputFn",
          "keepIframeSrcFn",
          "recordCanvas",
          "inlineImages",
          "slimDOMOptions",
          "dataURLOptions",
          "doc",
          "mirror",
          "iframeManager",
          "stylesheetManager",
          "shadowDomManager",
          "canvasManager",
          "processedNodeManager"
        ].forEach((key) => {
          this[key] = options[key];
        });
      }
      freeze() {
        this.frozen = true;
        this.canvasManager.freeze();
      }
      unfreeze() {
        this.frozen = false;
        this.canvasManager.unfreeze();
        this.emit();
      }
      isFrozen() {
        return this.frozen;
      }
      lock() {
        this.locked = true;
        this.canvasManager.lock();
      }
      unlock() {
        this.locked = false;
        this.canvasManager.unlock();
        this.emit();
      }
      reset() {
        this.shadowDomManager.reset();
        this.canvasManager.reset();
      }
    }
    function deepDelete(addsSet, n) {
      addsSet.delete(n);
      n.childNodes.forEach((childN) => deepDelete(addsSet, childN));
    }
    function isParentRemoved(removes, n, mirror) {
      if (removes.length === 0)
        return false;
      return _isParentRemoved(removes, n, mirror);
    }
    function _isParentRemoved(removes, n, mirror) {
      const { parentNode } = n;
      if (!parentNode) {
        return false;
      }
      const parentId = mirror.getId(parentNode);
      if (removes.some((r) => r.id === parentId)) {
        return true;
      }
      return _isParentRemoved(removes, parentNode, mirror);
    }
    function isAncestorInSet(set, n) {
      if (set.size === 0)
        return false;
      return _isAncestorInSet(set, n);
    }
    function _isAncestorInSet(set, n) {
      const { parentNode } = n;
      if (!parentNode) {
        return false;
      }
      if (set.has(parentNode)) {
        return true;
      }
      return _isAncestorInSet(set, parentNode);
    }

    let errorHandler;
    function registerErrorHandler(handler) {
      errorHandler = handler;
    }
    function unregisterErrorHandler() {
      errorHandler = void 0;
    }
    const callbackWrapper = (cb) => {
      if (!errorHandler) {
        return cb;
      }
      const rrwebWrapped = (...rest) => {
        try {
          return cb(...rest);
        } catch (error) {
          if (errorHandler && errorHandler(error) === true) {
            return;
          }
          throw error;
        }
      };
      return rrwebWrapped;
    };

    var __defProp$2 = Object.defineProperty;
    var __defProps$2 = Object.defineProperties;
    var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
    var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
    var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$2 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp$3.call(b, prop))
          __defNormalProp$2(a, prop, b[prop]);
      if (__getOwnPropSymbols$3)
        for (var prop of __getOwnPropSymbols$3(b)) {
          if (__propIsEnum$3.call(b, prop))
            __defNormalProp$2(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
    const mutationBuffers = [];
    function getEventTarget(event) {
      try {
        if ("composedPath" in event) {
          const path = event.composedPath();
          if (path.length) {
            return path[0];
          }
        } else if ("path" in event && event.path.length) {
          return event.path[0];
        }
      } catch (e) {
      }
      return event && event.target;
    }
    function initMutationObserver(options, rootEl) {
      var _a, _b;
      const mutationBuffer = new MutationBuffer();
      mutationBuffers.push(mutationBuffer);
      mutationBuffer.init(options);
      let mutationObserverCtor = window.MutationObserver || window.__rrMutationObserver;
      const angularZoneSymbol = (_b = (_a = window == null ? void 0 : window.Zone) == null ? void 0 : _a.__symbol__) == null ? void 0 : _b.call(_a, "MutationObserver");
      if (angularZoneSymbol && window[angularZoneSymbol]) {
        mutationObserverCtor = window[angularZoneSymbol];
      }
      const observer = new mutationObserverCtor(callbackWrapper(mutationBuffer.processMutations.bind(mutationBuffer)));
      observer.observe(rootEl, {
        attributes: true,
        attributeOldValue: true,
        characterData: true,
        characterDataOldValue: true,
        childList: true,
        subtree: true
      });
      return observer;
    }
    function initMoveObserver({
      mousemoveCb,
      sampling,
      doc,
      mirror
    }) {
      if (sampling.mousemove === false) {
        return () => {
        };
      }
      const threshold = typeof sampling.mousemove === "number" ? sampling.mousemove : 50;
      const callbackThreshold = typeof sampling.mousemoveCallback === "number" ? sampling.mousemoveCallback : 500;
      let positions = [];
      let timeBaseline;
      const wrappedCb = throttle(callbackWrapper((source) => {
        const totalOffset = Date.now() - timeBaseline;
        mousemoveCb(positions.map((p) => {
          p.timeOffset -= totalOffset;
          return p;
        }), source);
        positions = [];
        timeBaseline = null;
      }), callbackThreshold);
      const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        const { clientX, clientY } = legacy_isTouchEvent(evt) ? evt.changedTouches[0] : evt;
        if (!timeBaseline) {
          timeBaseline = nowTimestamp();
        }
        positions.push({
          x: clientX,
          y: clientY,
          id: mirror.getId(target),
          timeOffset: nowTimestamp() - timeBaseline
        });
        wrappedCb(typeof DragEvent !== "undefined" && evt instanceof DragEvent ? IncrementalSource.Drag : evt instanceof MouseEvent ? IncrementalSource.MouseMove : IncrementalSource.TouchMove);
      }), threshold, {
        trailing: false
      }));
      const handlers = [
        on("mousemove", updatePosition, doc),
        on("touchmove", updatePosition, doc),
        on("drag", updatePosition, doc)
      ];
      return callbackWrapper(() => {
        handlers.forEach((h) => h());
      });
    }
    function initMouseInteractionObserver({
      mouseInteractionCb,
      doc,
      mirror,
      blockClass,
      blockSelector,
      sampling
    }) {
      if (sampling.mouseInteraction === false) {
        return () => {
        };
      }
      const disableMap = sampling.mouseInteraction === true || sampling.mouseInteraction === void 0 ? {} : sampling.mouseInteraction;
      const handlers = [];
      let currentPointerType = null;
      const getHandler = (eventKey) => {
        return (event) => {
          const target = getEventTarget(event);
          if (isBlocked(target, blockClass, blockSelector, true)) {
            return;
          }
          let pointerType = null;
          let thisEventKey = eventKey;
          if ("pointerType" in event) {
            switch (event.pointerType) {
              case "mouse":
                pointerType = PointerTypes.Mouse;
                break;
              case "touch":
                pointerType = PointerTypes.Touch;
                break;
              case "pen":
                pointerType = PointerTypes.Pen;
                break;
            }
            if (pointerType === PointerTypes.Touch) {
              if (MouseInteractions[eventKey] === MouseInteractions.MouseDown) {
                thisEventKey = "TouchStart";
              } else if (MouseInteractions[eventKey] === MouseInteractions.MouseUp) {
                thisEventKey = "TouchEnd";
              }
            } else if (pointerType === PointerTypes.Pen) ;
          } else if (legacy_isTouchEvent(event)) {
            pointerType = PointerTypes.Touch;
          }
          if (pointerType !== null) {
            currentPointerType = pointerType;
            if (thisEventKey.startsWith("Touch") && pointerType === PointerTypes.Touch || thisEventKey.startsWith("Mouse") && pointerType === PointerTypes.Mouse) {
              pointerType = null;
            }
          } else if (MouseInteractions[eventKey] === MouseInteractions.Click) {
            pointerType = currentPointerType;
            currentPointerType = null;
          }
          const e = legacy_isTouchEvent(event) ? event.changedTouches[0] : event;
          if (!e) {
            return;
          }
          const id = mirror.getId(target);
          const { clientX, clientY } = e;
          callbackWrapper(mouseInteractionCb)(__spreadValues$2({
            type: MouseInteractions[thisEventKey],
            id,
            x: clientX,
            y: clientY
          }, pointerType !== null && { pointerType }));
        };
      };
      Object.keys(MouseInteractions).filter((key) => Number.isNaN(Number(key)) && !key.endsWith("_Departed") && disableMap[key] !== false).forEach((eventKey) => {
        let eventName = toLowerCase(eventKey);
        const handler = getHandler(eventKey);
        if (window.PointerEvent) {
          switch (MouseInteractions[eventKey]) {
            case MouseInteractions.MouseDown:
            case MouseInteractions.MouseUp:
              eventName = eventName.replace("mouse", "pointer");
              break;
            case MouseInteractions.TouchStart:
            case MouseInteractions.TouchEnd:
              return;
          }
        }
        handlers.push(on(eventName, handler, doc));
      });
      return callbackWrapper(() => {
        handlers.forEach((h) => h());
      });
    }
    function initScrollObserver({
      scrollCb,
      doc,
      mirror,
      blockClass,
      blockSelector,
      sampling
    }) {
      const updatePosition = callbackWrapper(throttle(callbackWrapper((evt) => {
        const target = getEventTarget(evt);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const id = mirror.getId(target);
        if (target === doc && doc.defaultView) {
          const scrollLeftTop = getWindowScroll(doc.defaultView);
          scrollCb({
            id,
            x: scrollLeftTop.left,
            y: scrollLeftTop.top
          });
        } else {
          scrollCb({
            id,
            x: target.scrollLeft,
            y: target.scrollTop
          });
        }
      }), sampling.scroll || 100));
      return on("scroll", updatePosition, doc);
    }
    function initViewportResizeObserver({ viewportResizeCb }, { win }) {
      let lastH = -1;
      let lastW = -1;
      const updateDimension = callbackWrapper(throttle(callbackWrapper(() => {
        const height = getWindowHeight();
        const width = getWindowWidth();
        if (lastH !== height || lastW !== width) {
          viewportResizeCb({
            width: Number(width),
            height: Number(height)
          });
          lastH = height;
          lastW = width;
        }
      }), 200));
      return on("resize", updateDimension, win);
    }
    const INPUT_TAGS = ["INPUT", "TEXTAREA", "SELECT"];
    const lastInputValueMap = /* @__PURE__ */ new WeakMap();
    function initInputObserver({
      inputCb,
      doc,
      mirror,
      blockClass,
      blockSelector,
      ignoreClass,
      ignoreSelector,
      maskInputOptions,
      maskInputFn,
      sampling,
      userTriggeredOnInput
    }) {
      function eventHandler(event) {
        let target = getEventTarget(event);
        const userTriggered = event.isTrusted;
        const tagName = target && target.tagName;
        if (target && tagName === "OPTION") {
          target = target.parentElement;
        }
        if (!target || !tagName || INPUT_TAGS.indexOf(tagName) < 0 || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        if (target.classList.contains(ignoreClass) || ignoreSelector && target.matches(ignoreSelector)) {
          return;
        }
        let text = target.value;
        let isChecked = false;
        const type = getInputType(target) || "";
        if (type === "radio" || type === "checkbox") {
          isChecked = target.checked;
        } else if (maskInputOptions[tagName.toLowerCase()] || maskInputOptions[type]) {
          text = maskInputValue({
            element: target,
            maskInputOptions,
            tagName,
            type,
            value: text,
            maskInputFn
          });
        }
        cbWithDedup(target, userTriggeredOnInput ? { text, isChecked, userTriggered } : { text, isChecked });
        const name = target.name;
        if (type === "radio" && name && isChecked) {
          doc.querySelectorAll(`input[type="radio"][name="${name}"]`).forEach((el) => {
            if (el !== target) {
              const text2 = el.value;
              cbWithDedup(el, userTriggeredOnInput ? { text: text2, isChecked: !isChecked, userTriggered: false } : { text: text2, isChecked: !isChecked });
            }
          });
        }
      }
      function cbWithDedup(target, v) {
        const lastInputValue = lastInputValueMap.get(target);
        if (!lastInputValue || lastInputValue.text !== v.text || lastInputValue.isChecked !== v.isChecked) {
          lastInputValueMap.set(target, v);
          const id = mirror.getId(target);
          callbackWrapper(inputCb)(__spreadProps$2(__spreadValues$2({}, v), {
            id
          }));
        }
      }
      const events = sampling.input === "last" ? ["change"] : ["input", "change"];
      const handlers = events.map((eventName) => on(eventName, callbackWrapper(eventHandler), doc));
      const currentWindow = doc.defaultView;
      if (!currentWindow) {
        return () => {
          handlers.forEach((h) => h());
        };
      }
      const propertyDescriptor = currentWindow.Object.getOwnPropertyDescriptor(currentWindow.HTMLInputElement.prototype, "value");
      const hookProperties = [
        [currentWindow.HTMLInputElement.prototype, "value"],
        [currentWindow.HTMLInputElement.prototype, "checked"],
        [currentWindow.HTMLSelectElement.prototype, "value"],
        [currentWindow.HTMLTextAreaElement.prototype, "value"],
        [currentWindow.HTMLSelectElement.prototype, "selectedIndex"],
        [currentWindow.HTMLOptionElement.prototype, "selected"]
      ];
      if (propertyDescriptor && propertyDescriptor.set) {
        handlers.push(...hookProperties.map((p) => hookSetter(p[0], p[1], {
          set() {
            callbackWrapper(eventHandler)({
              target: this,
              isTrusted: false
            });
          }
        }, false, currentWindow)));
      }
      return callbackWrapper(() => {
        handlers.forEach((h) => h());
      });
    }
    function getNestedCSSRulePositions(rule) {
      const positions = [];
      function recurse(childRule, pos) {
        if (hasNestedCSSRule("CSSGroupingRule") && childRule.parentRule instanceof CSSGroupingRule || hasNestedCSSRule("CSSMediaRule") && childRule.parentRule instanceof CSSMediaRule || hasNestedCSSRule("CSSSupportsRule") && childRule.parentRule instanceof CSSSupportsRule || hasNestedCSSRule("CSSConditionRule") && childRule.parentRule instanceof CSSConditionRule) {
          const rules = Array.from(childRule.parentRule.cssRules);
          const index = rules.indexOf(childRule);
          pos.unshift(index);
        } else if (childRule.parentStyleSheet) {
          const rules = Array.from(childRule.parentStyleSheet.cssRules);
          const index = rules.indexOf(childRule);
          pos.unshift(index);
        }
        return pos;
      }
      return recurse(rule, positions);
    }
    function getIdAndStyleId(sheet, mirror, styleMirror) {
      let id, styleId;
      if (!sheet)
        return {};
      if (sheet.ownerNode)
        id = mirror.getId(sheet.ownerNode);
      else
        styleId = styleMirror.getId(sheet);
      return {
        styleId,
        id
      };
    }
    function initStyleSheetObserver({ styleSheetRuleCb, mirror, stylesheetManager }, { win }) {
      if (!win.CSSStyleSheet || !win.CSSStyleSheet.prototype) {
        return () => {
        };
      }
      const insertRule = win.CSSStyleSheet.prototype.insertRule;
      win.CSSStyleSheet.prototype.insertRule = new Proxy(insertRule, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          const [rule, index] = argumentsList;
          const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              adds: [{ rule, index }]
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
      const deleteRule = win.CSSStyleSheet.prototype.deleteRule;
      win.CSSStyleSheet.prototype.deleteRule = new Proxy(deleteRule, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          const [index] = argumentsList;
          const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleSheetRuleCb({
              id,
              styleId,
              removes: [{ index }]
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
      let replace;
      if (win.CSSStyleSheet.prototype.replace) {
        replace = win.CSSStyleSheet.prototype.replace;
        win.CSSStyleSheet.prototype.replace = new Proxy(replace, {
          apply: callbackWrapper((target, thisArg, argumentsList) => {
            const [text] = argumentsList;
            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                replace: text
              });
            }
            return target.apply(thisArg, argumentsList);
          })
        });
      }
      let replaceSync;
      if (win.CSSStyleSheet.prototype.replaceSync) {
        replaceSync = win.CSSStyleSheet.prototype.replaceSync;
        win.CSSStyleSheet.prototype.replaceSync = new Proxy(replaceSync, {
          apply: callbackWrapper((target, thisArg, argumentsList) => {
            const [text] = argumentsList;
            const { id, styleId } = getIdAndStyleId(thisArg, mirror, stylesheetManager.styleMirror);
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                replaceSync: text
              });
            }
            return target.apply(thisArg, argumentsList);
          })
        });
      }
      const supportedNestedCSSRuleTypes = {};
      if (canMonkeyPatchNestedCSSRule("CSSGroupingRule")) {
        supportedNestedCSSRuleTypes.CSSGroupingRule = win.CSSGroupingRule;
      } else {
        if (canMonkeyPatchNestedCSSRule("CSSMediaRule")) {
          supportedNestedCSSRuleTypes.CSSMediaRule = win.CSSMediaRule;
        }
        if (canMonkeyPatchNestedCSSRule("CSSConditionRule")) {
          supportedNestedCSSRuleTypes.CSSConditionRule = win.CSSConditionRule;
        }
        if (canMonkeyPatchNestedCSSRule("CSSSupportsRule")) {
          supportedNestedCSSRuleTypes.CSSSupportsRule = win.CSSSupportsRule;
        }
      }
      const unmodifiedFunctions = {};
      Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
        unmodifiedFunctions[typeKey] = {
          insertRule: type.prototype.insertRule,
          deleteRule: type.prototype.deleteRule
        };
        type.prototype.insertRule = new Proxy(unmodifiedFunctions[typeKey].insertRule, {
          apply: callbackWrapper((target, thisArg, argumentsList) => {
            const [rule, index] = argumentsList;
            const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                adds: [
                  {
                    rule,
                    index: [
                      ...getNestedCSSRulePositions(thisArg),
                      index || 0
                    ]
                  }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          })
        });
        type.prototype.deleteRule = new Proxy(unmodifiedFunctions[typeKey].deleteRule, {
          apply: callbackWrapper((target, thisArg, argumentsList) => {
            const [index] = argumentsList;
            const { id, styleId } = getIdAndStyleId(thisArg.parentStyleSheet, mirror, stylesheetManager.styleMirror);
            if (id && id !== -1 || styleId && styleId !== -1) {
              styleSheetRuleCb({
                id,
                styleId,
                removes: [
                  { index: [...getNestedCSSRulePositions(thisArg), index] }
                ]
              });
            }
            return target.apply(thisArg, argumentsList);
          })
        });
      });
      return callbackWrapper(() => {
        win.CSSStyleSheet.prototype.insertRule = insertRule;
        win.CSSStyleSheet.prototype.deleteRule = deleteRule;
        replace && (win.CSSStyleSheet.prototype.replace = replace);
        replaceSync && (win.CSSStyleSheet.prototype.replaceSync = replaceSync);
        Object.entries(supportedNestedCSSRuleTypes).forEach(([typeKey, type]) => {
          type.prototype.insertRule = unmodifiedFunctions[typeKey].insertRule;
          type.prototype.deleteRule = unmodifiedFunctions[typeKey].deleteRule;
        });
      });
    }
    function initAdoptedStyleSheetObserver({
      mirror,
      stylesheetManager
    }, host) {
      var _a, _b, _c;
      let hostId = null;
      if (host.nodeName === "#document")
        hostId = mirror.getId(host);
      else
        hostId = mirror.getId(host.host);
      const patchTarget = host.nodeName === "#document" ? (_a = host.defaultView) == null ? void 0 : _a.Document : (_c = (_b = host.ownerDocument) == null ? void 0 : _b.defaultView) == null ? void 0 : _c.ShadowRoot;
      const originalPropertyDescriptor = (patchTarget == null ? void 0 : patchTarget.prototype) ? Object.getOwnPropertyDescriptor(patchTarget == null ? void 0 : patchTarget.prototype, "adoptedStyleSheets") : void 0;
      if (hostId === null || hostId === -1 || !patchTarget || !originalPropertyDescriptor)
        return () => {
        };
      Object.defineProperty(host, "adoptedStyleSheets", {
        configurable: originalPropertyDescriptor.configurable,
        enumerable: originalPropertyDescriptor.enumerable,
        get() {
          var _a2;
          return (_a2 = originalPropertyDescriptor.get) == null ? void 0 : _a2.call(this);
        },
        set(sheets) {
          var _a2;
          const result = (_a2 = originalPropertyDescriptor.set) == null ? void 0 : _a2.call(this, sheets);
          if (hostId !== null && hostId !== -1) {
            try {
              stylesheetManager.adoptStyleSheets(sheets, hostId);
            } catch (e) {
            }
          }
          return result;
        }
      });
      return callbackWrapper(() => {
        Object.defineProperty(host, "adoptedStyleSheets", {
          configurable: originalPropertyDescriptor.configurable,
          enumerable: originalPropertyDescriptor.enumerable,
          get: originalPropertyDescriptor.get,
          set: originalPropertyDescriptor.set
        });
      });
    }
    function initStyleDeclarationObserver({
      styleDeclarationCb,
      mirror,
      ignoreCSSAttributes,
      stylesheetManager
    }, { win }) {
      const setProperty = win.CSSStyleDeclaration.prototype.setProperty;
      win.CSSStyleDeclaration.prototype.setProperty = new Proxy(setProperty, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          var _a;
          const [property, value, priority] = argumentsList;
          if (ignoreCSSAttributes.has(property)) {
            return setProperty.apply(thisArg, [property, value, priority]);
          }
          const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) == null ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleDeclarationCb({
              id,
              styleId,
              set: {
                property,
                value,
                priority
              },
              index: getNestedCSSRulePositions(thisArg.parentRule)
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
      const removeProperty = win.CSSStyleDeclaration.prototype.removeProperty;
      win.CSSStyleDeclaration.prototype.removeProperty = new Proxy(removeProperty, {
        apply: callbackWrapper((target, thisArg, argumentsList) => {
          var _a;
          const [property] = argumentsList;
          if (ignoreCSSAttributes.has(property)) {
            return removeProperty.apply(thisArg, [property]);
          }
          const { id, styleId } = getIdAndStyleId((_a = thisArg.parentRule) == null ? void 0 : _a.parentStyleSheet, mirror, stylesheetManager.styleMirror);
          if (id && id !== -1 || styleId && styleId !== -1) {
            styleDeclarationCb({
              id,
              styleId,
              remove: {
                property
              },
              index: getNestedCSSRulePositions(thisArg.parentRule)
            });
          }
          return target.apply(thisArg, argumentsList);
        })
      });
      return callbackWrapper(() => {
        win.CSSStyleDeclaration.prototype.setProperty = setProperty;
        win.CSSStyleDeclaration.prototype.removeProperty = removeProperty;
      });
    }
    function initMediaInteractionObserver({
      mediaInteractionCb,
      blockClass,
      blockSelector,
      mirror,
      sampling,
      doc
    }) {
      const handler = callbackWrapper((type) => throttle(callbackWrapper((event) => {
        const target = getEventTarget(event);
        if (!target || isBlocked(target, blockClass, blockSelector, true)) {
          return;
        }
        const { currentTime, volume, muted, playbackRate, loop } = target;
        mediaInteractionCb({
          type,
          id: mirror.getId(target),
          currentTime,
          volume,
          muted,
          playbackRate,
          loop
        });
      }), sampling.media || 500));
      const handlers = [
        on("play", handler(MediaInteractions.Play), doc),
        on("pause", handler(MediaInteractions.Pause), doc),
        on("seeked", handler(MediaInteractions.Seeked), doc),
        on("volumechange", handler(MediaInteractions.VolumeChange), doc),
        on("ratechange", handler(MediaInteractions.RateChange), doc)
      ];
      return callbackWrapper(() => {
        handlers.forEach((h) => h());
      });
    }
    function initFontObserver({ fontCb, doc }) {
      const win = doc.defaultView;
      if (!win) {
        return () => {
        };
      }
      const handlers = [];
      const fontMap = /* @__PURE__ */ new WeakMap();
      const originalFontFace = win.FontFace;
      win.FontFace = function FontFace(family, source, descriptors) {
        const fontFace = new originalFontFace(family, source, descriptors);
        fontMap.set(fontFace, {
          family,
          buffer: typeof source !== "string",
          descriptors,
          fontSource: typeof source === "string" ? source : JSON.stringify(Array.from(new Uint8Array(source)))
        });
        return fontFace;
      };
      const restoreHandler = patch(doc.fonts, "add", function(original) {
        return function(fontFace) {
          setTimeout(callbackWrapper(() => {
            const p = fontMap.get(fontFace);
            if (p) {
              fontCb(p);
              fontMap.delete(fontFace);
            }
          }), 0);
          return original.apply(this, [fontFace]);
        };
      });
      handlers.push(() => {
        win.FontFace = originalFontFace;
      });
      handlers.push(restoreHandler);
      return callbackWrapper(() => {
        handlers.forEach((h) => h());
      });
    }
    function initSelectionObserver(param) {
      const { doc, mirror, blockClass, blockSelector, selectionCb } = param;
      let collapsed = true;
      const updateSelection = callbackWrapper(() => {
        const selection = doc.getSelection();
        if (!selection || collapsed && (selection == null ? void 0 : selection.isCollapsed))
          return;
        collapsed = selection.isCollapsed || false;
        const ranges = [];
        const count = selection.rangeCount || 0;
        for (let i = 0; i < count; i++) {
          const range = selection.getRangeAt(i);
          const { startContainer, startOffset, endContainer, endOffset } = range;
          const blocked = isBlocked(startContainer, blockClass, blockSelector, true) || isBlocked(endContainer, blockClass, blockSelector, true);
          if (blocked)
            continue;
          ranges.push({
            start: mirror.getId(startContainer),
            startOffset,
            end: mirror.getId(endContainer),
            endOffset
          });
        }
        selectionCb({ ranges });
      });
      updateSelection();
      return on("selectionchange", updateSelection);
    }
    function initCustomElementObserver({
      doc,
      customElementCb
    }) {
      const win = doc.defaultView;
      if (!win || !win.customElements)
        return () => {
        };
      const restoreHandler = patch(win.customElements, "define", function(original) {
        return function(name, constructor, options) {
          try {
            customElementCb({
              define: {
                name
              }
            });
          } catch (e) {
            console.warn(`Custom element callback failed for ${name}`);
          }
          return original.apply(this, [name, constructor, options]);
        };
      });
      return restoreHandler;
    }
    function mergeHooks(o, hooks) {
      const {
        mutationCb,
        mousemoveCb,
        mouseInteractionCb,
        scrollCb,
        viewportResizeCb,
        inputCb,
        mediaInteractionCb,
        styleSheetRuleCb,
        styleDeclarationCb,
        canvasMutationCb,
        fontCb,
        selectionCb,
        customElementCb
      } = o;
      o.mutationCb = (...p) => {
        if (hooks.mutation) {
          hooks.mutation(...p);
        }
        mutationCb(...p);
      };
      o.mousemoveCb = (...p) => {
        if (hooks.mousemove) {
          hooks.mousemove(...p);
        }
        mousemoveCb(...p);
      };
      o.mouseInteractionCb = (...p) => {
        if (hooks.mouseInteraction) {
          hooks.mouseInteraction(...p);
        }
        mouseInteractionCb(...p);
      };
      o.scrollCb = (...p) => {
        if (hooks.scroll) {
          hooks.scroll(...p);
        }
        scrollCb(...p);
      };
      o.viewportResizeCb = (...p) => {
        if (hooks.viewportResize) {
          hooks.viewportResize(...p);
        }
        viewportResizeCb(...p);
      };
      o.inputCb = (...p) => {
        if (hooks.input) {
          hooks.input(...p);
        }
        inputCb(...p);
      };
      o.mediaInteractionCb = (...p) => {
        if (hooks.mediaInteaction) {
          hooks.mediaInteaction(...p);
        }
        mediaInteractionCb(...p);
      };
      o.styleSheetRuleCb = (...p) => {
        if (hooks.styleSheetRule) {
          hooks.styleSheetRule(...p);
        }
        styleSheetRuleCb(...p);
      };
      o.styleDeclarationCb = (...p) => {
        if (hooks.styleDeclaration) {
          hooks.styleDeclaration(...p);
        }
        styleDeclarationCb(...p);
      };
      o.canvasMutationCb = (...p) => {
        if (hooks.canvasMutation) {
          hooks.canvasMutation(...p);
        }
        canvasMutationCb(...p);
      };
      o.fontCb = (...p) => {
        if (hooks.font) {
          hooks.font(...p);
        }
        fontCb(...p);
      };
      o.selectionCb = (...p) => {
        if (hooks.selection) {
          hooks.selection(...p);
        }
        selectionCb(...p);
      };
      o.customElementCb = (...c) => {
        if (hooks.customElement) {
          hooks.customElement(...c);
        }
        customElementCb(...c);
      };
    }
    function initObservers(o, hooks = {}) {
      const currentWindow = o.doc.defaultView;
      if (!currentWindow) {
        return () => {
        };
      }
      mergeHooks(o, hooks);
      let mutationObserver;
      if (o.recordDOM) {
        mutationObserver = initMutationObserver(o, o.doc);
      }
      const mousemoveHandler = initMoveObserver(o);
      const mouseInteractionHandler = initMouseInteractionObserver(o);
      const scrollHandler = initScrollObserver(o);
      const viewportResizeHandler = initViewportResizeObserver(o, {
        win: currentWindow
      });
      const inputHandler = initInputObserver(o);
      const mediaInteractionHandler = initMediaInteractionObserver(o);
      let styleSheetObserver = () => {
      };
      let adoptedStyleSheetObserver = () => {
      };
      let styleDeclarationObserver = () => {
      };
      let fontObserver = () => {
      };
      if (o.recordDOM) {
        styleSheetObserver = initStyleSheetObserver(o, { win: currentWindow });
        adoptedStyleSheetObserver = initAdoptedStyleSheetObserver(o, o.doc);
        styleDeclarationObserver = initStyleDeclarationObserver(o, {
          win: currentWindow
        });
        if (o.collectFonts) {
          fontObserver = initFontObserver(o);
        }
      }
      const selectionObserver = initSelectionObserver(o);
      const customElementObserver = initCustomElementObserver(o);
      const pluginHandlers = [];
      for (const plugin of o.plugins) {
        pluginHandlers.push(plugin.observer(plugin.callback, currentWindow, plugin.options));
      }
      return callbackWrapper(() => {
        mutationBuffers.forEach((b) => b.reset());
        mutationObserver == null ? void 0 : mutationObserver.disconnect();
        mousemoveHandler();
        mouseInteractionHandler();
        scrollHandler();
        viewportResizeHandler();
        inputHandler();
        mediaInteractionHandler();
        styleSheetObserver();
        adoptedStyleSheetObserver();
        styleDeclarationObserver();
        fontObserver();
        selectionObserver();
        customElementObserver();
        pluginHandlers.forEach((h) => h());
      });
    }
    function hasNestedCSSRule(prop) {
      return typeof window[prop] !== "undefined";
    }
    function canMonkeyPatchNestedCSSRule(prop) {
      return Boolean(typeof window[prop] !== "undefined" && window[prop].prototype && "insertRule" in window[prop].prototype && "deleteRule" in window[prop].prototype);
    }

    class CrossOriginIframeMirror {
      constructor(generateIdFn) {
        this.generateIdFn = generateIdFn;
        this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
        this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
      }
      getId(iframe, remoteId, idToRemoteMap, remoteToIdMap) {
        const idToRemoteIdMap = idToRemoteMap || this.getIdToRemoteIdMap(iframe);
        const remoteIdToIdMap = remoteToIdMap || this.getRemoteIdToIdMap(iframe);
        let id = idToRemoteIdMap.get(remoteId);
        if (!id) {
          id = this.generateIdFn();
          idToRemoteIdMap.set(remoteId, id);
          remoteIdToIdMap.set(id, remoteId);
        }
        return id;
      }
      getIds(iframe, remoteId) {
        const idToRemoteIdMap = this.getIdToRemoteIdMap(iframe);
        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
        return remoteId.map((id) => this.getId(iframe, id, idToRemoteIdMap, remoteIdToIdMap));
      }
      getRemoteId(iframe, id, map) {
        const remoteIdToIdMap = map || this.getRemoteIdToIdMap(iframe);
        if (typeof id !== "number")
          return id;
        const remoteId = remoteIdToIdMap.get(id);
        if (!remoteId)
          return -1;
        return remoteId;
      }
      getRemoteIds(iframe, ids) {
        const remoteIdToIdMap = this.getRemoteIdToIdMap(iframe);
        return ids.map((id) => this.getRemoteId(iframe, id, remoteIdToIdMap));
      }
      reset(iframe) {
        if (!iframe) {
          this.iframeIdToRemoteIdMap = /* @__PURE__ */ new WeakMap();
          this.iframeRemoteIdToIdMap = /* @__PURE__ */ new WeakMap();
          return;
        }
        this.iframeIdToRemoteIdMap.delete(iframe);
        this.iframeRemoteIdToIdMap.delete(iframe);
      }
      getIdToRemoteIdMap(iframe) {
        let idToRemoteIdMap = this.iframeIdToRemoteIdMap.get(iframe);
        if (!idToRemoteIdMap) {
          idToRemoteIdMap = /* @__PURE__ */ new Map();
          this.iframeIdToRemoteIdMap.set(iframe, idToRemoteIdMap);
        }
        return idToRemoteIdMap;
      }
      getRemoteIdToIdMap(iframe) {
        let remoteIdToIdMap = this.iframeRemoteIdToIdMap.get(iframe);
        if (!remoteIdToIdMap) {
          remoteIdToIdMap = /* @__PURE__ */ new Map();
          this.iframeRemoteIdToIdMap.set(iframe, remoteIdToIdMap);
        }
        return remoteIdToIdMap;
      }
    }

    class IframeManager {
      constructor(options) {
        this.iframes = /* @__PURE__ */ new WeakMap();
        this.crossOriginIframeMap = /* @__PURE__ */ new WeakMap();
        this.crossOriginIframeMirror = new CrossOriginIframeMirror(genId);
        this.crossOriginIframeRootIdMap = /* @__PURE__ */ new WeakMap();
        this.mutationCb = options.mutationCb;
        this.wrappedEmit = options.wrappedEmit;
        this.stylesheetManager = options.stylesheetManager;
        this.recordCrossOriginIframes = options.recordCrossOriginIframes;
        this.crossOriginIframeStyleMirror = new CrossOriginIframeMirror(this.stylesheetManager.styleMirror.generateId.bind(this.stylesheetManager.styleMirror));
        this.mirror = options.mirror;
        if (this.recordCrossOriginIframes) {
          window.addEventListener("message", this.handleMessage.bind(this));
        }
      }
      addIframe(iframeEl) {
        this.iframes.set(iframeEl, true);
        if (iframeEl.contentWindow)
          this.crossOriginIframeMap.set(iframeEl.contentWindow, iframeEl);
      }
      addLoadListener(cb) {
        this.loadListener = cb;
      }
      attachIframe(iframeEl, childSn) {
        var _a;
        this.mutationCb({
          adds: [
            {
              parentId: this.mirror.getId(iframeEl),
              nextId: null,
              node: childSn
            }
          ],
          removes: [],
          texts: [],
          attributes: [],
          isAttachIframe: true
        });
        (_a = this.loadListener) == null ? void 0 : _a.call(this, iframeEl);
        if (iframeEl.contentDocument && iframeEl.contentDocument.adoptedStyleSheets && iframeEl.contentDocument.adoptedStyleSheets.length > 0)
          this.stylesheetManager.adoptStyleSheets(iframeEl.contentDocument.adoptedStyleSheets, this.mirror.getId(iframeEl.contentDocument));
      }
      handleMessage(message) {
        const crossOriginMessageEvent = message;
        if (crossOriginMessageEvent.data.type !== "rrweb" || crossOriginMessageEvent.origin !== crossOriginMessageEvent.data.origin)
          return;
        const iframeSourceWindow = message.source;
        if (!iframeSourceWindow)
          return;
        const iframeEl = this.crossOriginIframeMap.get(message.source);
        if (!iframeEl)
          return;
        const transformedEvent = this.transformCrossOriginEvent(iframeEl, crossOriginMessageEvent.data.event);
        if (transformedEvent)
          this.wrappedEmit(transformedEvent, crossOriginMessageEvent.data.isCheckout);
      }
      transformCrossOriginEvent(iframeEl, e) {
        var _a;
        switch (e.type) {
          case EventType.FullSnapshot: {
            this.crossOriginIframeMirror.reset(iframeEl);
            this.crossOriginIframeStyleMirror.reset(iframeEl);
            this.replaceIdOnNode(e.data.node, iframeEl);
            const rootId = e.data.node.id;
            this.crossOriginIframeRootIdMap.set(iframeEl, rootId);
            this.patchRootIdOnNode(e.data.node, rootId);
            return {
              timestamp: e.timestamp,
              type: EventType.IncrementalSnapshot,
              data: {
                source: IncrementalSource.Mutation,
                adds: [
                  {
                    parentId: this.mirror.getId(iframeEl),
                    nextId: null,
                    node: e.data.node
                  }
                ],
                removes: [],
                texts: [],
                attributes: [],
                isAttachIframe: true
              }
            };
          }
          case EventType.Meta:
          case EventType.Load:
          case EventType.DomContentLoaded: {
            return false;
          }
          case EventType.Plugin: {
            return e;
          }
          case EventType.Custom: {
            this.replaceIds(e.data.payload, iframeEl, ["id", "parentId", "previousId", "nextId"]);
            return e;
          }
          case EventType.IncrementalSnapshot: {
            switch (e.data.source) {
              case IncrementalSource.Mutation: {
                e.data.adds.forEach((n) => {
                  this.replaceIds(n, iframeEl, [
                    "parentId",
                    "nextId",
                    "previousId"
                  ]);
                  this.replaceIdOnNode(n.node, iframeEl);
                  const rootId = this.crossOriginIframeRootIdMap.get(iframeEl);
                  rootId && this.patchRootIdOnNode(n.node, rootId);
                });
                e.data.removes.forEach((n) => {
                  this.replaceIds(n, iframeEl, ["parentId", "id"]);
                });
                e.data.attributes.forEach((n) => {
                  this.replaceIds(n, iframeEl, ["id"]);
                });
                e.data.texts.forEach((n) => {
                  this.replaceIds(n, iframeEl, ["id"]);
                });
                return e;
              }
              case IncrementalSource.Drag:
              case IncrementalSource.TouchMove:
              case IncrementalSource.MouseMove: {
                e.data.positions.forEach((p) => {
                  this.replaceIds(p, iframeEl, ["id"]);
                });
                return e;
              }
              case IncrementalSource.ViewportResize: {
                return false;
              }
              case IncrementalSource.MediaInteraction:
              case IncrementalSource.MouseInteraction:
              case IncrementalSource.Scroll:
              case IncrementalSource.CanvasMutation:
              case IncrementalSource.Input: {
                this.replaceIds(e.data, iframeEl, ["id"]);
                return e;
              }
              case IncrementalSource.StyleSheetRule:
              case IncrementalSource.StyleDeclaration: {
                this.replaceIds(e.data, iframeEl, ["id"]);
                this.replaceStyleIds(e.data, iframeEl, ["styleId"]);
                return e;
              }
              case IncrementalSource.Font: {
                return e;
              }
              case IncrementalSource.Selection: {
                e.data.ranges.forEach((range) => {
                  this.replaceIds(range, iframeEl, ["start", "end"]);
                });
                return e;
              }
              case IncrementalSource.AdoptedStyleSheet: {
                this.replaceIds(e.data, iframeEl, ["id"]);
                this.replaceStyleIds(e.data, iframeEl, ["styleIds"]);
                (_a = e.data.styles) == null ? void 0 : _a.forEach((style) => {
                  this.replaceStyleIds(style, iframeEl, ["styleId"]);
                });
                return e;
              }
            }
          }
        }
        return false;
      }
      replace(iframeMirror, obj, iframeEl, keys) {
        for (const key of keys) {
          if (!Array.isArray(obj[key]) && typeof obj[key] !== "number")
            continue;
          if (Array.isArray(obj[key])) {
            obj[key] = iframeMirror.getIds(iframeEl, obj[key]);
          } else {
            obj[key] = iframeMirror.getId(iframeEl, obj[key]);
          }
        }
        return obj;
      }
      replaceIds(obj, iframeEl, keys) {
        return this.replace(this.crossOriginIframeMirror, obj, iframeEl, keys);
      }
      replaceStyleIds(obj, iframeEl, keys) {
        return this.replace(this.crossOriginIframeStyleMirror, obj, iframeEl, keys);
      }
      replaceIdOnNode(node, iframeEl) {
        this.replaceIds(node, iframeEl, ["id", "rootId"]);
        if ("childNodes" in node) {
          node.childNodes.forEach((child) => {
            this.replaceIdOnNode(child, iframeEl);
          });
        }
      }
      patchRootIdOnNode(node, rootId) {
        if (node.type !== NodeType.Document && !node.rootId)
          node.rootId = rootId;
        if ("childNodes" in node) {
          node.childNodes.forEach((child) => {
            this.patchRootIdOnNode(child, rootId);
          });
        }
      }
    }

    var __defProp$1 = Object.defineProperty;
    var __defProps$1 = Object.defineProperties;
    var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
    var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
    var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
    var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues$1 = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp$2.call(b, prop))
          __defNormalProp$1(a, prop, b[prop]);
      if (__getOwnPropSymbols$2)
        for (var prop of __getOwnPropSymbols$2(b)) {
          if (__propIsEnum$2.call(b, prop))
            __defNormalProp$1(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
    class ShadowDomManager {
      constructor(options) {
        this.shadowDoms = /* @__PURE__ */ new WeakSet();
        this.restoreHandlers = [];
        this.mutationCb = options.mutationCb;
        this.scrollCb = options.scrollCb;
        this.bypassOptions = options.bypassOptions;
        this.mirror = options.mirror;
        this.init();
      }
      init() {
        this.reset();
        this.patchAttachShadow(Element, document);
      }
      addShadowRoot(shadowRoot, doc) {
        if (!isNativeShadowDom(shadowRoot))
          return;
        if (this.shadowDoms.has(shadowRoot))
          return;
        this.shadowDoms.add(shadowRoot);
        const observer = initMutationObserver(__spreadProps$1(__spreadValues$1({}, this.bypassOptions), {
          doc,
          mutationCb: this.mutationCb,
          mirror: this.mirror,
          shadowDomManager: this
        }), shadowRoot);
        this.restoreHandlers.push(() => observer.disconnect());
        this.restoreHandlers.push(initScrollObserver(__spreadProps$1(__spreadValues$1({}, this.bypassOptions), {
          scrollCb: this.scrollCb,
          doc: shadowRoot,
          mirror: this.mirror
        })));
        setTimeout(() => {
          if (shadowRoot.adoptedStyleSheets && shadowRoot.adoptedStyleSheets.length > 0)
            this.bypassOptions.stylesheetManager.adoptStyleSheets(shadowRoot.adoptedStyleSheets, this.mirror.getId(shadowRoot.host));
          this.restoreHandlers.push(initAdoptedStyleSheetObserver({
            mirror: this.mirror,
            stylesheetManager: this.bypassOptions.stylesheetManager
          }, shadowRoot));
        }, 0);
      }
      observeAttachShadow(iframeElement) {
        if (!iframeElement.contentWindow || !iframeElement.contentDocument)
          return;
        this.patchAttachShadow(iframeElement.contentWindow.Element, iframeElement.contentDocument);
      }
      patchAttachShadow(element, doc) {
        const manager = this;
        this.restoreHandlers.push(patch(element.prototype, "attachShadow", function(original) {
          return function(option) {
            const shadowRoot = original.call(this, option);
            if (this.shadowRoot && inDom(this))
              manager.addShadowRoot(this.shadowRoot, doc);
            return shadowRoot;
          };
        }));
      }
      reset() {
        this.restoreHandlers.forEach((handler) => {
          try {
            handler();
          } catch (e) {
          }
        });
        this.restoreHandlers = [];
        this.shadowDoms = /* @__PURE__ */ new WeakSet();
      }
    }

    /*
     * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
     * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
     * Released under MIT License
     */
    var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    // Use a lookup table to find the index.
    var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
    for (var i = 0; i < chars.length; i++) {
        lookup[chars.charCodeAt(i)] = i;
    }
    var encode = function (arraybuffer) {
        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
        for (i = 0; i < len; i += 3) {
            base64 += chars[bytes[i] >> 2];
            base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
            base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
            base64 += chars[bytes[i + 2] & 63];
        }
        if (len % 3 === 2) {
            base64 = base64.substring(0, base64.length - 1) + '=';
        }
        else if (len % 3 === 1) {
            base64 = base64.substring(0, base64.length - 2) + '==';
        }
        return base64;
    };

    const canvasVarMap = /* @__PURE__ */ new Map();
    function variableListFor(ctx, ctor) {
      let contextMap = canvasVarMap.get(ctx);
      if (!contextMap) {
        contextMap = /* @__PURE__ */ new Map();
        canvasVarMap.set(ctx, contextMap);
      }
      if (!contextMap.has(ctor)) {
        contextMap.set(ctor, []);
      }
      return contextMap.get(ctor);
    }
    const saveWebGLVar = (value, win, ctx) => {
      if (!value || !(isInstanceOfWebGLObject(value, win) || typeof value === "object"))
        return;
      const name = value.constructor.name;
      const list = variableListFor(ctx, name);
      let index = list.indexOf(value);
      if (index === -1) {
        index = list.length;
        list.push(value);
      }
      return index;
    };
    function serializeArg(value, win, ctx) {
      if (value instanceof Array) {
        return value.map((arg) => serializeArg(arg, win, ctx));
      } else if (value === null) {
        return value;
      } else if (value instanceof Float32Array || value instanceof Float64Array || value instanceof Int32Array || value instanceof Uint32Array || value instanceof Uint8Array || value instanceof Uint16Array || value instanceof Int16Array || value instanceof Int8Array || value instanceof Uint8ClampedArray) {
        const name = value.constructor.name;
        return {
          rr_type: name,
          args: [Object.values(value)]
        };
      } else if (value instanceof ArrayBuffer) {
        const name = value.constructor.name;
        const base64 = encode(value);
        return {
          rr_type: name,
          base64
        };
      } else if (value instanceof DataView) {
        const name = value.constructor.name;
        return {
          rr_type: name,
          args: [
            serializeArg(value.buffer, win, ctx),
            value.byteOffset,
            value.byteLength
          ]
        };
      } else if (value instanceof HTMLImageElement) {
        const name = value.constructor.name;
        const { src } = value;
        return {
          rr_type: name,
          src
        };
      } else if (value instanceof HTMLCanvasElement) {
        const name = "HTMLImageElement";
        const src = value.toDataURL();
        return {
          rr_type: name,
          src
        };
      } else if (value instanceof ImageData) {
        const name = value.constructor.name;
        return {
          rr_type: name,
          args: [serializeArg(value.data, win, ctx), value.width, value.height]
        };
      } else if (isInstanceOfWebGLObject(value, win) || typeof value === "object") {
        const name = value.constructor.name;
        const index = saveWebGLVar(value, win, ctx);
        return {
          rr_type: name,
          index
        };
      }
      return value;
    }
    const serializeArgs = (args, win, ctx) => {
      return args.map((arg) => serializeArg(arg, win, ctx));
    };
    const isInstanceOfWebGLObject = (value, win) => {
      const webGLConstructorNames = [
        "WebGLActiveInfo",
        "WebGLBuffer",
        "WebGLFramebuffer",
        "WebGLProgram",
        "WebGLRenderbuffer",
        "WebGLShader",
        "WebGLShaderPrecisionFormat",
        "WebGLTexture",
        "WebGLUniformLocation",
        "WebGLVertexArrayObject",
        "WebGLVertexArrayObjectOES"
      ];
      const supportedWebGLConstructorNames = webGLConstructorNames.filter((name) => typeof win[name] === "function");
      return Boolean(supportedWebGLConstructorNames.find((name) => value instanceof win[name]));
    };

    function initCanvas2DMutationObserver(cb, win, blockClass2, blockSelector) {
      const handlers = [];
      const props2D = Object.getOwnPropertyNames(win.CanvasRenderingContext2D.prototype);
      for (const prop of props2D) {
        try {
          if (typeof win.CanvasRenderingContext2D.prototype[prop] !== "function") {
            continue;
          }
          const restoreHandler = patch(win.CanvasRenderingContext2D.prototype, prop, function(original) {
            return function(...args) {
              if (!isBlocked(this.canvas, blockClass2, blockSelector, true)) {
                setTimeout(() => {
                  const recordArgs = serializeArgs(args, win, this);
                  cb(this.canvas, {
                    type: CanvasContext["2D"],
                    property: prop,
                    args: recordArgs
                  });
                }, 0);
              }
              return original.apply(this, args);
            };
          });
          handlers.push(restoreHandler);
        } catch (e) {
          const hookHandler = hookSetter(win.CanvasRenderingContext2D.prototype, prop, {
            set(v) {
              cb(this.canvas, {
                type: CanvasContext["2D"],
                property: prop,
                args: [v],
                setter: true
              });
            }
          });
          handlers.push(hookHandler);
        }
      }
      return () => {
        handlers.forEach((h) => h());
      };
    }

    function getNormalizedContextName(contextType) {
      return contextType === "experimental-webgl" ? "webgl" : contextType;
    }
    function initCanvasContextObserver(win, blockClass, blockSelector, setPreserveDrawingBufferToTrue) {
      const handlers = [];
      try {
        const restoreHandler = patch(win.HTMLCanvasElement.prototype, "getContext", function(original) {
          return function(contextType, ...args) {
            if (!isBlocked(this, blockClass, blockSelector, true)) {
              const ctxName = getNormalizedContextName(contextType);
              if (!("__context" in this))
                this.__context = ctxName;
              if (setPreserveDrawingBufferToTrue && ["webgl", "webgl2"].includes(ctxName)) {
                if (args[0] && typeof args[0] === "object") {
                  const contextAttributes = args[0];
                  if (!contextAttributes.preserveDrawingBuffer) {
                    contextAttributes.preserveDrawingBuffer = true;
                  }
                } else {
                  args.splice(0, 1, {
                    preserveDrawingBuffer: true
                  });
                }
              }
            }
            return original.apply(this, [contextType, ...args]);
          };
        });
        handlers.push(restoreHandler);
      } catch (e) {
        console.error("failed to patch HTMLCanvasElement.prototype.getContext");
      }
      return () => {
        handlers.forEach((h) => h());
      };
    }

    function patchGLPrototype(prototype, type, cb, blockClass2, blockSelector, mirror, win) {
      const handlers = [];
      const props = Object.getOwnPropertyNames(prototype);
      for (const prop of props) {
        if ([
          "isContextLost",
          "canvas",
          "drawingBufferWidth",
          "drawingBufferHeight"
        ].includes(prop)) {
          continue;
        }
        try {
          if (typeof prototype[prop] !== "function") {
            continue;
          }
          const restoreHandler = patch(prototype, prop, function(original) {
            return function(...args) {
              const result = original.apply(this, args);
              saveWebGLVar(result, win, this);
              if ("tagName" in this.canvas && !isBlocked(this.canvas, blockClass2, blockSelector, true)) {
                const recordArgs = serializeArgs(args, win, this);
                const mutation = {
                  type,
                  property: prop,
                  args: recordArgs
                };
                cb(this.canvas, mutation);
              }
              return result;
            };
          });
          handlers.push(restoreHandler);
        } catch (e) {
          const hookHandler = hookSetter(prototype, prop, {
            set(v) {
              cb(this.canvas, {
                type,
                property: prop,
                args: [v],
                setter: true
              });
            }
          });
          handlers.push(hookHandler);
        }
      }
      return handlers;
    }
    function initCanvasWebGLMutationObserver(cb, win, blockClass2, blockSelector, mirror) {
      const handlers = [];
      handlers.push(...patchGLPrototype(win.WebGLRenderingContext.prototype, CanvasContext.WebGL, cb, blockClass2, blockSelector, mirror, win));
      if (typeof win.WebGL2RenderingContext !== "undefined") {
        handlers.push(...patchGLPrototype(win.WebGL2RenderingContext.prototype, CanvasContext.WebGL2, cb, blockClass2, blockSelector, mirror, win));
      }
      return () => {
        handlers.forEach((h) => h());
      };
    }

    function funcToSource(fn, sourcemapArg) {
        var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
        var source = fn.toString();
        var lines = source.split('\n');
        lines.pop();
        lines.shift();
        var blankPrefixLength = lines[0].search(/\S/);
        var regex = /(['"])__worker_loader_strict__(['"])/g;
        for (var i = 0, n = lines.length; i < n; ++i) {
            lines[i] = lines[i].substring(blankPrefixLength).replace(regex, '$1use strict$2') + '\n';
        }
        if (sourcemap) {
            lines.push('\/\/# sourceMappingURL=' + sourcemap + '\n');
        }
        return lines;
    }

    function createURL(fn, sourcemapArg) {
        var lines = funcToSource(fn, sourcemapArg);
        var blob = new Blob(lines, { type: 'application/javascript' });
        return URL.createObjectURL(blob);
    }

    function createInlineWorkerFactory(fn, sourcemapArg) {
        var url;
        return function WorkerFactory(options) {
            url = url || createURL(fn, sourcemapArg);
            return new Worker(url, options);
        };
    }

    var WorkerFactory = createInlineWorkerFactory(/* rollup-plugin-web-worker-loader */function () {
    (function () {
        '__worker_loader_strict__';

        /*
         * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
         * Copyright (c) 2021 Niklas von Hertzen <https://hertzen.com>
         * Released under MIT License
         */
        var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        // Use a lookup table to find the index.
        var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);
        for (var i = 0; i < chars.length; i++) {
            lookup[chars.charCodeAt(i)] = i;
        }
        var encode = function (arraybuffer) {
            var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';
            for (i = 0; i < len; i += 3) {
                base64 += chars[bytes[i] >> 2];
                base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
                base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
                base64 += chars[bytes[i + 2] & 63];
            }
            if (len % 3 === 2) {
                base64 = base64.substring(0, base64.length - 1) + '=';
            }
            else if (len % 3 === 1) {
                base64 = base64.substring(0, base64.length - 2) + '==';
            }
            return base64;
        };

        const lastBlobMap = /* @__PURE__ */ new Map();
        const transparentBlobMap = /* @__PURE__ */ new Map();
        async function getTransparentBlobFor(width, height, dataURLOptions) {
          const id = `${width}-${height}`;
          if ("OffscreenCanvas" in globalThis) {
            if (transparentBlobMap.has(id))
              return transparentBlobMap.get(id);
            const offscreen = new OffscreenCanvas(width, height);
            offscreen.getContext("2d");
            const blob = await offscreen.convertToBlob(dataURLOptions);
            const arrayBuffer = await blob.arrayBuffer();
            const base64 = encode(arrayBuffer);
            transparentBlobMap.set(id, base64);
            return base64;
          } else {
            return "";
          }
        }
        const worker = self;
        worker.onmessage = async function(e) {
          if ("OffscreenCanvas" in globalThis) {
            const { id, bitmap, width, height, dataURLOptions } = e.data;
            const transparentBase64 = getTransparentBlobFor(width, height, dataURLOptions);
            const offscreen = new OffscreenCanvas(width, height);
            const ctx = offscreen.getContext("2d");
            ctx.drawImage(bitmap, 0, 0);
            bitmap.close();
            const blob = await offscreen.convertToBlob(dataURLOptions);
            const type = blob.type;
            const arrayBuffer = await blob.arrayBuffer();
            const base64 = encode(arrayBuffer);
            if (!lastBlobMap.has(id) && await transparentBase64 === base64) {
              lastBlobMap.set(id, base64);
              return worker.postMessage({ id });
            }
            if (lastBlobMap.get(id) === base64)
              return worker.postMessage({ id });
            worker.postMessage({
              id,
              type,
              base64,
              width,
              height
            });
            lastBlobMap.set(id, base64);
          } else {
            return worker.postMessage({ id: e.data.id });
          }
        };

    })();
    }, null);
    /* eslint-enable */

    var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
    var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
    var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
    var __objRest = (source, exclude) => {
      var target = {};
      for (var prop in source)
        if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)
          target[prop] = source[prop];
      if (source != null && __getOwnPropSymbols$1)
        for (var prop of __getOwnPropSymbols$1(source)) {
          if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))
            target[prop] = source[prop];
        }
      return target;
    };
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    class CanvasManager {
      constructor(options) {
        this.pendingCanvasMutations = /* @__PURE__ */ new Map();
        this.rafStamps = { latestId: 0, invokeId: null };
        this.frozen = false;
        this.locked = false;
        this.processMutation = (target, mutation) => {
          const newFrame = this.rafStamps.invokeId && this.rafStamps.latestId !== this.rafStamps.invokeId;
          if (newFrame || !this.rafStamps.invokeId)
            this.rafStamps.invokeId = this.rafStamps.latestId;
          if (!this.pendingCanvasMutations.has(target)) {
            this.pendingCanvasMutations.set(target, []);
          }
          this.pendingCanvasMutations.get(target).push(mutation);
        };
        const {
          sampling = "all",
          win,
          blockClass,
          blockSelector,
          recordCanvas,
          dataURLOptions
        } = options;
        this.mutationCb = options.mutationCb;
        this.mirror = options.mirror;
        if (recordCanvas && sampling === "all")
          this.initCanvasMutationObserver(win, blockClass, blockSelector);
        if (recordCanvas && typeof sampling === "number")
          this.initCanvasFPSObserver(sampling, win, blockClass, blockSelector, {
            dataURLOptions
          });
      }
      reset() {
        this.pendingCanvasMutations.clear();
        this.resetObservers && this.resetObservers();
      }
      freeze() {
        this.frozen = true;
      }
      unfreeze() {
        this.frozen = false;
      }
      lock() {
        this.locked = true;
      }
      unlock() {
        this.locked = false;
      }
      initCanvasFPSObserver(fps, win, blockClass, blockSelector, options) {
        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, true);
        const snapshotInProgressMap = /* @__PURE__ */ new Map();
        const worker = new WorkerFactory();
        worker.onmessage = (e) => {
          const { id } = e.data;
          snapshotInProgressMap.set(id, false);
          if (!("base64" in e.data))
            return;
          const { base64, type, width, height } = e.data;
          this.mutationCb({
            id,
            type: CanvasContext["2D"],
            commands: [
              {
                property: "clearRect",
                args: [0, 0, width, height]
              },
              {
                property: "drawImage",
                args: [
                  {
                    rr_type: "ImageBitmap",
                    args: [
                      {
                        rr_type: "Blob",
                        data: [{ rr_type: "ArrayBuffer", base64 }],
                        type
                      }
                    ]
                  },
                  0,
                  0
                ]
              }
            ]
          });
        };
        const timeBetweenSnapshots = 1e3 / fps;
        let lastSnapshotTime = 0;
        let rafId;
        const getCanvas = () => {
          const matchedCanvas = [];
          win.document.querySelectorAll("canvas").forEach((canvas) => {
            if (!isBlocked(canvas, blockClass, blockSelector, true)) {
              matchedCanvas.push(canvas);
            }
          });
          return matchedCanvas;
        };
        const takeCanvasSnapshots = (timestamp) => {
          if (lastSnapshotTime && timestamp - lastSnapshotTime < timeBetweenSnapshots) {
            rafId = requestAnimationFrame(takeCanvasSnapshots);
            return;
          }
          lastSnapshotTime = timestamp;
          getCanvas().forEach((canvas) => __async(this, null, function* () {
            var _a;
            const id = this.mirror.getId(canvas);
            if (snapshotInProgressMap.get(id))
              return;
            if (canvas.width === 0 || canvas.height === 0)
              return;
            snapshotInProgressMap.set(id, true);
            if (["webgl", "webgl2"].includes(canvas.__context)) {
              const context = canvas.getContext(canvas.__context);
              if (((_a = context == null ? void 0 : context.getContextAttributes()) == null ? void 0 : _a.preserveDrawingBuffer) === false) {
                context.clear(context.COLOR_BUFFER_BIT);
              }
            }
            const bitmap = yield createImageBitmap(canvas);
            worker.postMessage({
              id,
              bitmap,
              width: canvas.width,
              height: canvas.height,
              dataURLOptions: options.dataURLOptions
            }, [bitmap]);
          }));
          rafId = requestAnimationFrame(takeCanvasSnapshots);
        };
        rafId = requestAnimationFrame(takeCanvasSnapshots);
        this.resetObservers = () => {
          canvasContextReset();
          cancelAnimationFrame(rafId);
        };
      }
      initCanvasMutationObserver(win, blockClass, blockSelector) {
        this.startRAFTimestamping();
        this.startPendingCanvasMutationFlusher();
        const canvasContextReset = initCanvasContextObserver(win, blockClass, blockSelector, false);
        const canvas2DReset = initCanvas2DMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector);
        const canvasWebGL1and2Reset = initCanvasWebGLMutationObserver(this.processMutation.bind(this), win, blockClass, blockSelector, this.mirror);
        this.resetObservers = () => {
          canvasContextReset();
          canvas2DReset();
          canvasWebGL1and2Reset();
        };
      }
      startPendingCanvasMutationFlusher() {
        requestAnimationFrame(() => this.flushPendingCanvasMutations());
      }
      startRAFTimestamping() {
        const setLatestRAFTimestamp = (timestamp) => {
          this.rafStamps.latestId = timestamp;
          requestAnimationFrame(setLatestRAFTimestamp);
        };
        requestAnimationFrame(setLatestRAFTimestamp);
      }
      flushPendingCanvasMutations() {
        this.pendingCanvasMutations.forEach((values, canvas) => {
          const id = this.mirror.getId(canvas);
          this.flushPendingCanvasMutationFor(canvas, id);
        });
        requestAnimationFrame(() => this.flushPendingCanvasMutations());
      }
      flushPendingCanvasMutationFor(canvas, id) {
        if (this.frozen || this.locked) {
          return;
        }
        const valuesWithType = this.pendingCanvasMutations.get(canvas);
        if (!valuesWithType || id === -1)
          return;
        const values = valuesWithType.map((value) => {
          const _a = value, rest = __objRest(_a, ["type"]);
          return rest;
        });
        const { type } = valuesWithType[0];
        this.mutationCb({ id, type, commands: values });
        this.pendingCanvasMutations.delete(canvas);
      }
    }

    class StylesheetManager {
      constructor(options) {
        this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
        this.styleMirror = new StyleSheetMirror();
        this.mutationCb = options.mutationCb;
        this.adoptedStyleSheetCb = options.adoptedStyleSheetCb;
      }
      attachLinkElement(linkEl, childSn) {
        if ("_cssText" in childSn.attributes)
          this.mutationCb({
            adds: [],
            removes: [],
            texts: [],
            attributes: [
              {
                id: childSn.id,
                attributes: childSn.attributes
              }
            ]
          });
        this.trackLinkElement(linkEl);
      }
      trackLinkElement(linkEl) {
        if (this.trackedLinkElements.has(linkEl))
          return;
        this.trackedLinkElements.add(linkEl);
        this.trackStylesheetInLinkElement(linkEl);
      }
      adoptStyleSheets(sheets, hostId) {
        if (sheets.length === 0)
          return;
        const adoptedStyleSheetData = {
          id: hostId,
          styleIds: []
        };
        const styles = [];
        for (const sheet of sheets) {
          let styleId;
          if (!this.styleMirror.has(sheet)) {
            styleId = this.styleMirror.add(sheet);
            styles.push({
              styleId,
              rules: Array.from(sheet.rules || CSSRule, (r, index) => ({
                rule: stringifyRule(r),
                index
              }))
            });
          } else
            styleId = this.styleMirror.getId(sheet);
          adoptedStyleSheetData.styleIds.push(styleId);
        }
        if (styles.length > 0)
          adoptedStyleSheetData.styles = styles;
        this.adoptedStyleSheetCb(adoptedStyleSheetData);
      }
      reset() {
        this.styleMirror.reset();
        this.trackedLinkElements = /* @__PURE__ */ new WeakSet();
      }
      trackStylesheetInLinkElement(linkEl) {
      }
    }

    class ProcessedNodeManager {
      constructor() {
        this.nodeMap = /* @__PURE__ */ new WeakMap();
        this.loop = true;
        this.periodicallyClear();
      }
      periodicallyClear() {
        requestAnimationFrame(() => {
          this.clear();
          if (this.loop)
            this.periodicallyClear();
        });
      }
      inOtherBuffer(node, thisBuffer) {
        const buffers = this.nodeMap.get(node);
        return buffers && Array.from(buffers).some((buffer) => buffer !== thisBuffer);
      }
      add(node, buffer) {
        this.nodeMap.set(node, (this.nodeMap.get(node) || /* @__PURE__ */ new Set()).add(buffer));
      }
      clear() {
        this.nodeMap = /* @__PURE__ */ new WeakMap();
      }
      destroy() {
        this.loop = false;
      }
    }

    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    function wrapEvent(e) {
      return __spreadProps(__spreadValues({}, e), {
        timestamp: nowTimestamp()
      });
    }
    let wrappedEmit;
    let takeFullSnapshot;
    let canvasManager;
    let recording = false;
    const mirror = createMirror();
    function record(options = {}) {
      const {
        emit,
        checkoutEveryNms,
        checkoutEveryNth,
        blockClass = "rr-block",
        blockSelector = null,
        ignoreClass = "rr-ignore",
        ignoreSelector = null,
        maskTextClass = "rr-mask",
        maskTextSelector = null,
        inlineStylesheet = true,
        maskAllInputs,
        maskInputOptions: _maskInputOptions,
        slimDOMOptions: _slimDOMOptions,
        maskInputFn,
        maskTextFn,
        hooks,
        packFn,
        sampling = {},
        dataURLOptions = {},
        mousemoveWait,
        recordDOM = true,
        recordCanvas = false,
        recordCrossOriginIframes = false,
        recordAfter = options.recordAfter === "DOMContentLoaded" ? options.recordAfter : "load",
        userTriggeredOnInput = false,
        collectFonts = false,
        inlineImages = false,
        plugins,
        keepIframeSrcFn = () => false,
        ignoreCSSAttributes = /* @__PURE__ */ new Set([]),
        errorHandler
      } = options;
      registerErrorHandler(errorHandler);
      const inEmittingFrame = recordCrossOriginIframes ? window.parent === window : true;
      let passEmitsToParent = false;
      if (!inEmittingFrame) {
        try {
          if (window.parent.document) {
            passEmitsToParent = false;
          }
        } catch (e) {
          passEmitsToParent = true;
        }
      }
      if (inEmittingFrame && !emit) {
        throw new Error("emit function is required");
      }
      if (mousemoveWait !== void 0 && sampling.mousemove === void 0) {
        sampling.mousemove = mousemoveWait;
      }
      mirror.reset();
      const maskInputOptions = maskAllInputs === true ? {
        color: true,
        date: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true,
        textarea: true,
        select: true,
        password: true
      } : _maskInputOptions !== void 0 ? _maskInputOptions : { password: true };
      const slimDOMOptions = _slimDOMOptions === true || _slimDOMOptions === "all" ? {
        script: true,
        comment: true,
        headFavicon: true,
        headWhitespace: true,
        headMetaSocial: true,
        headMetaRobots: true,
        headMetaHttpEquiv: true,
        headMetaVerification: true,
        headMetaAuthorship: _slimDOMOptions === "all",
        headMetaDescKeywords: _slimDOMOptions === "all"
      } : _slimDOMOptions ? _slimDOMOptions : {};
      polyfill();
      let lastFullSnapshotEvent;
      let incrementalSnapshotCount = 0;
      const eventProcessor = (e) => {
        for (const plugin of plugins || []) {
          if (plugin.eventProcessor) {
            e = plugin.eventProcessor(e);
          }
        }
        if (packFn && !passEmitsToParent) {
          e = packFn(e);
        }
        return e;
      };
      wrappedEmit = (e, isCheckout) => {
        var _a;
        if (((_a = mutationBuffers[0]) == null ? void 0 : _a.isFrozen()) && e.type !== EventType.FullSnapshot && !(e.type === EventType.IncrementalSnapshot && e.data.source === IncrementalSource.Mutation)) {
          mutationBuffers.forEach((buf) => buf.unfreeze());
        }
        if (inEmittingFrame) {
          emit == null ? void 0 : emit(eventProcessor(e), isCheckout);
        } else if (passEmitsToParent) {
          const message = {
            type: "rrweb",
            event: eventProcessor(e),
            origin: window.location.origin,
            isCheckout
          };
          window.parent.postMessage(message, "*");
        }
        if (e.type === EventType.FullSnapshot) {
          lastFullSnapshotEvent = e;
          incrementalSnapshotCount = 0;
        } else if (e.type === EventType.IncrementalSnapshot) {
          if (e.data.source === IncrementalSource.Mutation && e.data.isAttachIframe) {
            return;
          }
          incrementalSnapshotCount++;
          const exceedCount = checkoutEveryNth && incrementalSnapshotCount >= checkoutEveryNth;
          const exceedTime = checkoutEveryNms && e.timestamp - lastFullSnapshotEvent.timestamp > checkoutEveryNms;
          if (exceedCount || exceedTime) {
            takeFullSnapshot(true);
          }
        }
      };
      const wrappedMutationEmit = (m) => {
        wrappedEmit(wrapEvent({
          type: EventType.IncrementalSnapshot,
          data: __spreadValues({
            source: IncrementalSource.Mutation
          }, m)
        }));
      };
      const wrappedScrollEmit = (p) => wrappedEmit(wrapEvent({
        type: EventType.IncrementalSnapshot,
        data: __spreadValues({
          source: IncrementalSource.Scroll
        }, p)
      }));
      const wrappedCanvasMutationEmit = (p) => wrappedEmit(wrapEvent({
        type: EventType.IncrementalSnapshot,
        data: __spreadValues({
          source: IncrementalSource.CanvasMutation
        }, p)
      }));
      const wrappedAdoptedStyleSheetEmit = (a) => wrappedEmit(wrapEvent({
        type: EventType.IncrementalSnapshot,
        data: __spreadValues({
          source: IncrementalSource.AdoptedStyleSheet
        }, a)
      }));
      const stylesheetManager = new StylesheetManager({
        mutationCb: wrappedMutationEmit,
        adoptedStyleSheetCb: wrappedAdoptedStyleSheetEmit
      });
      const iframeManager = new IframeManager({
        mirror,
        mutationCb: wrappedMutationEmit,
        stylesheetManager,
        recordCrossOriginIframes,
        wrappedEmit
      });
      for (const plugin of plugins || []) {
        if (plugin.getMirror)
          plugin.getMirror({
            nodeMirror: mirror,
            crossOriginIframeMirror: iframeManager.crossOriginIframeMirror,
            crossOriginIframeStyleMirror: iframeManager.crossOriginIframeStyleMirror
          });
      }
      const processedNodeManager = new ProcessedNodeManager();
      canvasManager = new CanvasManager({
        recordCanvas,
        mutationCb: wrappedCanvasMutationEmit,
        win: window,
        blockClass,
        blockSelector,
        mirror,
        sampling: sampling.canvas,
        dataURLOptions
      });
      const shadowDomManager = new ShadowDomManager({
        mutationCb: wrappedMutationEmit,
        scrollCb: wrappedScrollEmit,
        bypassOptions: {
          blockClass,
          blockSelector,
          maskTextClass,
          maskTextSelector,
          inlineStylesheet,
          maskInputOptions,
          dataURLOptions,
          maskTextFn,
          maskInputFn,
          recordCanvas,
          inlineImages,
          sampling,
          slimDOMOptions,
          iframeManager,
          stylesheetManager,
          canvasManager,
          keepIframeSrcFn,
          processedNodeManager
        },
        mirror
      });
      takeFullSnapshot = (isCheckout = false) => {
        if (!recordDOM) {
          return;
        }
        wrappedEmit(wrapEvent({
          type: EventType.Meta,
          data: {
            href: window.location.href,
            width: getWindowWidth(),
            height: getWindowHeight()
          }
        }), isCheckout);
        stylesheetManager.reset();
        shadowDomManager.init();
        mutationBuffers.forEach((buf) => buf.lock());
        const node = snapshot(document, {
          mirror,
          blockClass,
          blockSelector,
          maskTextClass,
          maskTextSelector,
          inlineStylesheet,
          maskAllInputs: maskInputOptions,
          maskTextFn,
          slimDOM: slimDOMOptions,
          dataURLOptions,
          recordCanvas,
          inlineImages,
          onSerialize: (n) => {
            if (isSerializedIframe(n, mirror)) {
              iframeManager.addIframe(n);
            }
            if (isSerializedStylesheet(n, mirror)) {
              stylesheetManager.trackLinkElement(n);
            }
            if (hasShadowRoot(n)) {
              shadowDomManager.addShadowRoot(n.shadowRoot, document);
            }
          },
          onIframeLoad: (iframe, childSn) => {
            iframeManager.attachIframe(iframe, childSn);
            shadowDomManager.observeAttachShadow(iframe);
          },
          onStylesheetLoad: (linkEl, childSn) => {
            stylesheetManager.attachLinkElement(linkEl, childSn);
          },
          keepIframeSrcFn
        });
        if (!node) {
          return console.warn("Failed to snapshot the document");
        }
        wrappedEmit(wrapEvent({
          type: EventType.FullSnapshot,
          data: {
            node,
            initialOffset: getWindowScroll(window)
          }
        }), isCheckout);
        mutationBuffers.forEach((buf) => buf.unlock());
        if (document.adoptedStyleSheets && document.adoptedStyleSheets.length > 0)
          stylesheetManager.adoptStyleSheets(document.adoptedStyleSheets, mirror.getId(document));
      };
      try {
        const handlers = [];
        const observe = (doc) => {
          var _a;
          return callbackWrapper(initObservers)({
            mutationCb: wrappedMutationEmit,
            mousemoveCb: (positions, source) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: {
                source,
                positions
              }
            })),
            mouseInteractionCb: (d) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.MouseInteraction
              }, d)
            })),
            scrollCb: wrappedScrollEmit,
            viewportResizeCb: (d) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.ViewportResize
              }, d)
            })),
            inputCb: (v) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.Input
              }, v)
            })),
            mediaInteractionCb: (p) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.MediaInteraction
              }, p)
            })),
            styleSheetRuleCb: (r) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.StyleSheetRule
              }, r)
            })),
            styleDeclarationCb: (r) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.StyleDeclaration
              }, r)
            })),
            canvasMutationCb: wrappedCanvasMutationEmit,
            fontCb: (p) => wrappedEmit(wrapEvent({
              type: EventType.IncrementalSnapshot,
              data: __spreadValues({
                source: IncrementalSource.Font
              }, p)
            })),
            selectionCb: (p) => {
              wrappedEmit(wrapEvent({
                type: EventType.IncrementalSnapshot,
                data: __spreadValues({
                  source: IncrementalSource.Selection
                }, p)
              }));
            },
            customElementCb: (c) => {
              wrappedEmit(wrapEvent({
                type: EventType.IncrementalSnapshot,
                data: __spreadValues({
                  source: IncrementalSource.CustomElement
                }, c)
              }));
            },
            blockClass,
            ignoreClass,
            ignoreSelector,
            maskTextClass,
            maskTextSelector,
            maskInputOptions,
            inlineStylesheet,
            sampling,
            recordDOM,
            recordCanvas,
            inlineImages,
            userTriggeredOnInput,
            collectFonts,
            doc,
            maskInputFn,
            maskTextFn,
            keepIframeSrcFn,
            blockSelector,
            slimDOMOptions,
            dataURLOptions,
            mirror,
            iframeManager,
            stylesheetManager,
            shadowDomManager,
            processedNodeManager,
            canvasManager,
            ignoreCSSAttributes,
            plugins: ((_a = plugins == null ? void 0 : plugins.filter((p) => p.observer)) == null ? void 0 : _a.map((p) => ({
              observer: p.observer,
              options: p.options,
              callback: (payload) => wrappedEmit(wrapEvent({
                type: EventType.Plugin,
                data: {
                  plugin: p.name,
                  payload
                }
              }))
            }))) || []
          }, hooks);
        };
        iframeManager.addLoadListener((iframeEl) => {
          try {
            handlers.push(observe(iframeEl.contentDocument));
          } catch (error) {
            console.warn(error);
          }
        });
        const init = () => {
          takeFullSnapshot();
          handlers.push(observe(document));
          recording = true;
        };
        if (document.readyState === "interactive" || document.readyState === "complete") {
          init();
        } else {
          handlers.push(on("DOMContentLoaded", () => {
            wrappedEmit(wrapEvent({
              type: EventType.DomContentLoaded,
              data: {}
            }));
            if (recordAfter === "DOMContentLoaded")
              init();
          }));
          handlers.push(on("load", () => {
            wrappedEmit(wrapEvent({
              type: EventType.Load,
              data: {}
            }));
            if (recordAfter === "load")
              init();
          }, window));
        }
        return () => {
          handlers.forEach((h) => h());
          processedNodeManager.destroy();
          recording = false;
          unregisterErrorHandler();
        };
      } catch (error) {
        console.warn(error);
      }
    }
    record.addCustomEvent = (tag, payload) => {
      if (!recording) {
        throw new Error("please add custom event after start recording");
      }
      wrappedEmit(wrapEvent({
        type: EventType.Custom,
        data: {
          tag,
          payload
        }
      }));
    };
    record.freezePage = () => {
      mutationBuffers.forEach((buf) => buf.freeze());
    };
    record.takeFullSnapshot = (isCheckout) => {
      if (!recording) {
        throw new Error("please take full snapshot after start recording");
      }
      takeFullSnapshot(isCheckout);
    };
    record.mirror = mirror;

    return record;

})();
